# 🍠 算法基础

---

## 1. 什么是算法

<img src="https://gitee.com/veal98/images/raw/master/img/20201130144420.png" style="zoom:60%;" />

**算法 alogorithm** 就是定义解决问题的计算过程，该过程去某个值或值的集合作为**输入 Input**，并产生某个值或值的集合作为**输出 Output**。这样算法就是由若干指令组成的有穷序列。

⭐ **算法 + 数据结构 = 程序**。

算法只有在合适的数据结构中才能发挥作用，数据结构的不同，会影响算法的选择和效率。

<u>一般认为，算法是由若干条指令组成的有穷序列，具有下列五个特性</u>：

- 确定性：每条指令都是明确的、无二义的

- 可行性：每条指令都必须是能够执行的

- 输入：允许有0个或多个输入量，取自特定的集合

- 输出：产生一个或多个输出，它（们）与输入量之间存在着某种特定的关系

- 有穷性：每一条指令执行的次数都是有穷的

## 2. 分析算法

我们可以从以下几个方面去分析算法：

### ① 问题的规模

**问题的规模**也即**输入规模**：将一个或多个整数，作为输入数据量的测度

比如，在一个数组中寻找 X，那么这个问题的规模就是这个数组的长度

### ② 占支配地位的运算

一般来说，我们分析算法的时候，关心的是该算法中占支配地位的运算。

比如说，在一个表中寻找数据元素 X，那么这个问题中占支配地位的运算就是 X 与表中的每一个项进行比较

再比如，对一个数组进行排序，那么这个问题中占支配地位的运算就是表中的两个数据项进行比较。

### ③ 时间复杂度

![](https://gitee.com/veal98/images/raw/master/img/20201130145255.png)

<u>用问题规模的某个函数来表示算法的基本执行次数, 这个表示基本执行次数的函数称为算法的时间复杂性（度）</u>，时间复杂度用 `T(n)` (或 `T(n,m)` 等) 来表示

👇 根据定义，可以归纳出基本的计算步骤：

- 计算出基本操作的执行次数 `T(n)`

  基本操作即算法中的每条语句（以 `;` 号作为分割），语句的执行次数也叫做语句的频度。在做算法分析时，一般默认为考虑最坏的情况。

-  计算出 T(n) 的数量级：即忽略常量、低次幂和最高次幂的系数。令 `f(n)=T(n)` 的数量级

💬 举个最简单的例子：

```java
sum=0；                 
for(i=0;i<n;i++)       
	sum++；
```

上面代码中第一行频度 1，第二行频度为 n，第三行频度为 n，所以 T(n) = n+n+1 = 2n+1。忽略常量、低次幂和最高次幂的系数，则 f(n)  = n

#### 渐进时间复杂度

所谓渐进时间复杂度就是**当问题的规模趋于极限情形时（相当大）的时间复杂度**

对于算法进行特别具体的细致分析虽然很好，但在实践中的实际价值有限。对于算法的时间性质和空间性质，最重要的是其数量级和趋势，这些是分析算法效率的主要部分。而计量算法基本操作数量的规模函数中那些常量因子可以忽略不计。例如，可以认为 $3n^2$ 和 $100n^2$ 属于同一个量级，如果两个算法处理同样规模实例的代价分别为这两个函数，就认为它们的效率“差不多”，都为 $n^2$ 级。

<u>即当 n 趋近于无穷大时，如果 $lim \frac{T(n)}{f(n)}$ 的值为不等于 0 的常数，则称 `f(n)` 是 `T(n)` 的同数量级函数。记作 `T(n) = O/Ω/Θ(f(n))`</u> 

表示渐近时间复杂度的三个记号：

- `T(n) = O(f(n))`

  对于给定的函数 f(n)，若存在 $c > 0$，和正整数 $n_0 ≥ 1$，使得当 $n≥n_0$ 时，总有 $T(n)≤c * f(n)$

  该记法给出了算法时间复杂度的**上界**，复杂度不可能比 $c*f(n)$ 更大

  比如 $T(n)=O(n^2)$ 表示该算法运行时间不会超过 $cn^2$

- `T(n) = Ω(f(n))`

  若存在 $c > 0$，和正整数 $n_0≥1$，使得当 $n≥n_0$ 时，存在无穷多个 n ，使得 $T(n)≥c*f(n)$ 成立

  该记法给出了算法时间复杂度的**下界**，复杂度不可能比 $c*f(n)$ 更小

  比如 $T(n)=Ω(n^2)$ 表示该算法运行时间不会低于 $cn^2$

- `T(n) = Θ(f(n))`

  若存在 $c1,c2>0$，和正整数 $n_0≥1$，使得当 $n≥n_0$ 时，总有 $T(n)≤c1*f(n)$，且有无穷多个 n，使得$T(n)≥c2*f(n)$成立, 即：`T(n) = O(f(n))`与`T(n) = Ω(f(n))`都成立

  该记法既给出了算法时间复杂度的**上界**，也给出了**下界**

  比如：$T(n)=Θ(n^2)$ 表示该算法的运行时间不会超过 $c_1n^2$ ，不会低于 $c_2n^2 $

三种记法的图示如下：

<img src="https://gitee.com/veal98/images/raw/master/img/20200915203916.png" style="zoom: 50%;" />

👇 归纳出基本的渐进时间复杂度的计算步骤：

- 计算出基本操作的执行次数 `T(n)`

  基本操作即算法中的每条语句（以 `;` 号作为分割），语句的执行次数也叫做语句的频度。在做算法分析时，一般默认为考虑最坏的情况。

-  计算出 T(n) 的数量级：即忽略常量、低次幂和最高次幂的系数。令 `f(n)=T(n)` 的数量级
- 用 `O/Ω/Θ` 来表示渐进时间复杂度

举个例子：

```java
int num1, num2; 
for(int i=0; i<n; i++){ 
    num1 += 1;  
    for(int j=1; j<=n; j*=2){  
        num2 += num1; 
    }
}
```

- 首先计算基本操作的执行次数：

  `int num1, num2;` 频度 = 1

  `for(int i=0; i<n; i++)` 中 `int i = 0` 频度 = 1；`i<n; i++` 两条语句的频度都为 n

  同样的，循环体内的语句 `num1 += 1;` 频度 = n

  嵌套循环 `for(int j=1; j<=n; j*=2)` 中 `int j = 1` 频度 = n；`j<=n; j*=2` 两条语句的频度都为 n*log2n

  同样的，循环体内的语句 `num2 += num1;` 频度 = n*log2n

  => $T(n) = 1 + 1 + n + n + n + n + 3n*log2n = 2 + 4n + 3n*log2n$

- 然后忽略掉T(n)中的常量、低次幂和最高次幂的系数：$f(n) = n*log2n$

- 最后，取渐进时间复杂度：

  $lim(T(n)/f(n)) = 2*(1/n)*(1/log2n) + 4*(1/log2n) + 3$

  当 n 趋向于无穷大，1/n 趋向于0，1/log2n 趋向于0，所以极限等于 3 不等于 0，则称 `f(n)` 是 `T(n)` 的同数量级函数 => $T(n) = O(n*log2n)$

#### 常见的渐进时间复杂度

大 O 记法的运算规则：

<img src="https://gitee.com/veal98/images/raw/master/img/20201003154506.png" style="zoom:50%;" />

<img src="https://gitee.com/veal98/images/raw/master/img/20200915211639.png" style="zoom: 67%;" />

运行效率（越小越好）：

⭐ $O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<<O(n!)<O(n^n)$

![](https://gitee.com/veal98/images/raw/master/img/20200915211134.png)

👇 下面对不同的量级给出一个具体的例子：

🔴 **常数阶 O(1)**

无论代码执行了多少行，<u>只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 O(1)</u>，如：

```java
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用 O(1) 来表示它的时间复杂度。

🔴 **线性阶 O(n)**

```java
for(i=1; i<=n; ++i){
   j = i;
   j++;
}
```

这段代码，`for `循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用 O(n) 来表示它的时间复杂度。

🔴 **对数阶 O(logN)**

还是先来看代码：

```java
int i = 1;
while(i < n){
    i = i * 2;
}
```

从上面代码可以看到，在 `while `循环里面，<u>每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了</u>。我们试着求解一下，假设循环 x 次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 $x = log2^n$,也就是说当循环 $log2^n$ 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)

🔴 **线性对数阶 O(nlogN)**

线性对数阶 O(nlogN) 其实非常容易理解，将时间复杂度为 O(logn) 的代码循环 N 遍的话，那么它的时间复杂度就是 n * O(logN)，也就是 O(nlogN)。

就拿上面的代码加一点修改来举例：

```java
for(m=1; m<n; m++){
    i = 1;
    while(i<n){
        i = i * 2;
    }
}
```

🔴 **平方阶 O(n²)**

平方阶 O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了：

```java
for(x=1; i<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

这段代码其实就是嵌套了 2 层 n 循环，它的时间复杂度就是 O(n*n)，即 O (n²)

如果将其中一层循环的 n 改成 m，即：

```java
for(x=1; i<=m; x++){
   for(i=1; i<=n; i++){
       j = i;
       j++;
    }
}
```

那它的时间复杂度就变成了 O(m*n)

#### 最坏/最好/平均时间复杂度

**最坏时间复杂度**：在规模为 n 的所有输入中，基本运算执行次数为最多的时间复杂度

**最好时间复杂度**：在规模为 n 的所有输入中，基本运算执行次数为最少的时间复杂度

**平均时间复杂度**：在规模为 n 的所有输入中，算法时间复杂度的平均值。一般假设每种输入情况以等概率出现。（其实我们上面讨论的渐进时间复杂度就是平均时间复杂度）

以顺序查找为例：

```java
public int find(int[] arr, int target) {
    int n = arr.length;
    for (int i = 0; i < n; i++) {
        // 依次遍历数组，如果找到和目标元素相同的值，在返回该值所在下标
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}
```

- 最好情况时间复杂度：目标元素刚好在数组**第一个位置**，那么只需要一次就能找到，时间复杂度很明显是常量阶 O(1)

- 最坏情况时间复杂度：目标元素在数组**最后一个位置**或者**不在数组中**，那么得需要遍历完整个数组才能得出结果，时间复杂度为 O(n)

- 平均时间复杂度：根据大 O 记法，T(n) = O(n)

### ④ 空间复杂度

**一个程序的空间复杂度是指运行完一个程序所需内存的大小**。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分。

- 固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。

- 可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。

<u>目前来说，除了在一些特殊情况下，我们都是更加注重时间复杂度，而不是空间复杂度。</u>

## 3. 如何评价算法

- **正确性**（评价算法的首要因素）

- **健壮性**

  算法/程序不仅对正确的输入要能计算出正确的结果，对不正确的输入也要能够应对处理

- **简单性**

  算法/程序的可读性好，易调试、改进

- **高效性**

  时间、空间复杂度较小，特别是时间复杂度

- **最优性**

  证明所给算法是解决同一类问题中最好的

## 💯 课后习题

> 🔈 题目来源 《计算机算法与分析 王晓东 - 第5版》

### ① 求下列函数的渐进表达式

- $3n^2 + 10n$

  $< 3n^2 + 10n^2 = 13n^2 = O(n^2)$

- $n^2 / 10 + 2^n$

  $< 2^n + 2^n = 2*2^n = O(2^n)$

- $21 + 1/n$

  $< 21 + 1 = 22 = O(1)$

- $log(n^3)$

  $=3log(n)=O(log(n))$

- $10log(3^n)$

  $= (10log3)n = O(n) $

### ② O(1) 和 O(2) 的区别

O(1) = O(2)，用 O(1) 、O(2) 表示同一个函数时，差别仅在于其中的常数因子。

### ③ 求函数渐进阶

<img src="https://gitee.com/veal98/images/raw/master/img/20201003161240.png" style="zoom: 45%;" />

- （1）由于 $logn^2$ 和 $logn + 5$ 并无直接的大小关系， $logn^2$ 可能小于某个常数乘以 $logn + 5$，也可能大于某个常数乘以 $logn + 5$。所以 $f(n) =θ(g(n))$

- （2）$log(n) < √n$，$f(n) = 2log(n) < 2 * √n = 2 * g(n)$。所以 $f(n) = O(g(n))$

- （3）$log(n) < n$， $f(n) = n > 2 * log(n) = 1 * g(n)$。所以 $f(n) =  Ω(g(n))$

- （4）$f(n) =  Ω(g(n))$

- （5）常数级别的比较： $f(n) =θ(g(n))$

- （6）$f(n) =  Ω(g(n))$

- （7）$2^n > n^2$，$f(n) > 1/100 * g(n)$。所以 $f(n) =  Ω(g(n))$

- （8）$2^n < 3^n$。所以 $f(n) =  O(g(n))$

### ④ n! 的阶

n! = $O(n^n)$

### ⑤ 3n + 1 问题

<img src="https://gitee.com/veal98/images/raw/master/img/20201130162244.png" style="zoom:67%;" />

在最坏情况下，该算法的时间复杂度下界为 Ω(logn)

<img src="https://gitee.com/veal98/images/raw/master/img/20201130162440.png" style="zoom:40%;" />

## 📚 References

- 《算法导论 — 第 3 版 机械工业出版社》
- 《计算机算法与分析 王晓东 - 第5版》
- [算法时间复杂度的计算 [整理]](https://www.iteye.com/blog/univasity-1164707)
- [算法—时间复杂度](https://blog.csdn.net/user11223344abc/article/details/81485842)
- [最好、最坏、平均、均摊时间复杂度分析](https://blog.csdn.net/weixin_38483589/article/details/84262167)