# 二叉树问题

---

## 定义并构建二叉树的公共代码

> 这套代码在以后的解题代码中就不贴了，都是一样的，如果有不同之处，我会再指出来的。

二叉树的定义如下：

```java
// 定义二叉树
static class TreeNode {
    private int val;
    private TreeNode left;
    private TreeNode right;

    public TreeNode (int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}
```

下面这套构建二叉树的代码对应如下的输入格式：

第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch 同理)

示例

```
输入
3 1
1 2 3
2 0 0
3 0 0
```

【具体代码】：

```java
// 构造二叉树
private static TreeNode createTree(Scanner sc) {
    String[] values = sc.nextLine().split(" ");
    if (values.length < 3) {
        return null;
    }

    int value = Integer.parseInt(values[0]);
    int left = Integer.parseInt(values[1]);
    int right = Integer.parseInt(values[2]);

    TreeNode root = new TreeNode(value);
    if (left != 0) {
        root.left = createTree(sc);
    }
    if (right != 0) {
        root.right = createTree(sc);
    }

    return root;
}

public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    sc.nextLine(); // 第一行没啥用
    TreeNode root = createTree(sc);
}
```

## CD161. 实现二叉树先序，中序和后序遍历

【题目链接】：

- NowCoder：[CD161. 实现二叉树先序，中序和后序遍历](https://www.nowcoder.com/practice/566f7f9d68c24691aa5abd8abefa798c?tpId=101&tqId=33229&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

分别按照二叉树先序，中序和后序打印所有的节点。

输入描述:

第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

输出描述:

输出三行，分别表示二叉树的先序，中序和后序。

示例1

```
输入
3 1
1 2 3
2 0 0
3 0 0

输出
1 2 3
2 1 3
2 3 1
```

【解题思路】：

下面代码给出了遍历的递归和非递归版本。另外如何构建二叉树也需要注意。

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行数据没啥用
        TreeNode root = createTree(sc);

        List<Integer> preOrderList = preOrderUnRecur(root);
        for (int i : preOrderList) {
            System.out.print(i + " ");
        }
        System.out.println();

        List<Integer> inOrderList = inOrderUnRecur(root);
        for (int i : inOrderList) {
            System.out.print(i + " ");
        }
        System.out.println();

        List<Integer> postOrderList = postOrderUnRecur(root);
        for (int i : postOrderList) {
            System.out.print(i + " ");
        }
        System.out.println();
    }

    // 先序遍历 - 递归
    private static List<Integer> preOrderRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>(); // 存储遍历结果
        if (root == null) {
            return res;
        }

        res.add(root.val);
        preOrderRecur(root.left);
        preOrderRecur(root.right);

        return res;
    }
    // 中序遍历 - 递归
    private static List<Integer> inOrderRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        inOrderRecur(root.left);
        res.add(root.val);
        inOrderRecur(root.right);

        return res;
    }
    // 后序遍历 - 递归
    private static List<Integer> postOrderRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        postOrderRecur(root.left);
        postOrderRecur(root.right);
        res.add(root.val);

        return res;
    }

    // 先序遍历 - 非递归
    private static List<Integer> preOrderUnRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Stack<TreeNode> stack = new Stack<>(); // 辅助栈
        TreeNode cur = root; // 工作指针
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                res.add(cur.val);
                cur = cur.left;
            }
            else {
                cur = stack.pop();
                cur = cur.right;
            }
        }

        return res;
    }
    // 中序遍历 - 非递归
    private static List<Integer> inOrderUnRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Stack<TreeNode> stack = new Stack<>(); // 辅助栈
        TreeNode cur = root; // 工作指针
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            else {
                cur = stack.pop();
                res.add(cur.val);
                cur = cur.right;
            }
        }

        return res;
    }
    // 后序遍历 - 非递归
    private static List<Integer> postOrderUnRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Stack<TreeNode> stack = new Stack<>(); // 辅助栈
        TreeNode cur = root; // 工作指针
        TreeNode recently = null; // 最近访问过的节点
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            else {
                // 获取栈顶元素
                cur = stack.peek();
                // 右孩子存在且未被访问过
                if (cur.right != null && recently != cur.right) {
                    cur = cur.right;
                    stack.push(cur);
                    cur = cur.left;
                }
                // 右孩子不存在或者已被访问过
                else {
                    cur = stack.pop();
                    res.add(cur.val);
                    recently = cur; // 设为最近访问节点
                    cur = null; // cur 重置(即继续获取栈顶元素并对其进行判断)
                }
            }

        }

        return res;
    }
}
```

## LC102/SO32. 层次遍历

【题目链接】：

- LeetCode：[102. 二叉树的层序遍历 — Medium](https://leetcode-cn.com/problems/binary-tree-level-order-traversal) 
- 剑指 Offer：[32 - II. 从上到下打印二叉树 II — Easy](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

【题目描述】：

给你一个二叉树，请你返回其按 层序遍历 得到的节点值（即逐层地，从左到右访问所有节点）。

示例：

```
二叉树：[3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7

返回其层序遍历结果：
[
  [3],
  [9,20],
  [15,7]
]
```

【解题思路】：

利用队列先进先出的特性（广度优先搜索）

【具体代码】：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        
        if(root == null)
            return res;
        
        queue.offer(root); // 队列尾部添加元素。offer 方法在超出队列界限的时候直接返回 false
        
        while(!queue.isEmpty()){
            List<Integer> level = new ArrayList<Integer>(); // 存储每个层的节点
            int currentLevelSize = queue.size();
            for (int i = 0; i < currentLevelSize; i ++){
                TreeNode node = queue.poll();
                level.add(node.val);
                if(node.left != null)
                    queue.offer(node.left);
                if(node.right != null)
                    queue.offer(node.right);
            }
            
            res.add(level);  
        }
        
        return res;
    }
}
```

## CD168/SO32. 二叉树的按层打印与 ZigZag 打印

【题目链接】：

- NowCoder：[CD168. 二叉树的按层打印与 ZigZag 打印](https://www.nowcoder.com/practice/6a1815a85bfc411d9295bc017e6b6dbe?tpId=101&tqId=33236&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- 剑指 Offer：[32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

【题目描述】：

给定一颗二叉树，分别实现按层和 ZigZag 打印二叉树。

ZigZag遍历: 意思是第一层从左到右遍历，第二层从右到左遍历，依次类推。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
先输出按层打印，再输出按ZigZag打印。
```

示例1

```
输入
8 1
1 2 3
2 4 0
4 0 0
3 5 6
5 7 8
6 0 0
7 0 0
8 0 0

输出
Level 1 : 1
Level 2 : 2 3
Level 3 : 4 5 6
Level 4 : 7 8
Level 1 from left to right: 1
Level 2 from right to left: 3 2
Level 3 from left to right: 4 5 6
Level 4 from right to left: 8 7
```

【解题思路】：

层次遍历没什么好说的。ZigZag 遍历也直接层次遍历，只不过奇数偶数行元素的插入顺序不一样。可以使用 LinkedList 双向链表存储每行数据，既能在头部添加（`addFirst`）也能在尾部添加（`addLast`）

【具体代码】：

> 这段代码无法 AC，尚未找到原因所在

```java
import java.util.*;

public class CD168 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        TreeNode root = createTree(sc);

        // 按层打印
        List<List<Integer>> levelList = printByLevel(root);
        for (int i = 0; i < levelList.size(); i ++) {
            System.out.print("Level " + (i + 1) + " : ");
            for (int j = 0; j < levelList.get(i).size(); j ++) {
                System.out.print(levelList.get(i).get(j) + " ");
            }
            System.out.println();
        }

        // zigZag 打印
        List<List<Integer>> zigzagList = printByZigzag(root);
        for (int i = 0; i < zigzagList.size(); i ++) {
            String lStr = "left";
            String rStr = "right";
            if ((i+1) % 2 == 0) {
                lStr = "right";
                rStr = "left";
            }
            System.out.print("Level " + (i + 1) + " from " + lStr + " to " + rStr + " : ");
            for (int j = 0; j < zigzagList.get(i).size(); j ++) {
                System.out.print(zigzagList.get(i).get(j) + " ");
            }
            System.out.println();
        }

    }

    // 按层打印
    private static List<List<Integer>> printByLevel(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>(); // 存储遍历结果
        if (root == null) {
            return res;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int sz = queue.size();
            List<Integer> level = new ArrayList<>(); // 存储每行遍历的结果
            for (int i = 0; i < sz; i ++) {
                TreeNode node = queue.poll();
                level.add(node.val);

                if(node.left != null)
                    queue.offer(node.left);
                if(node.right != null)
                    queue.offer(node.right);
            }
            res.add(level);
        }

        return res;
    }

    // zigZag 打印
    private static List<List<Integer>> printByZigzag(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>(); // 存储遍历结果
        if (root == null) {
            return res;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        int height = 1;

        while (!queue.isEmpty()) {
            int sz = queue.size();
            // 双向链表存储每行数据，既能在头部添加也能在尾部添加
            LinkedList<Integer> line = new LinkedList<>();
            for (int i = 0; i < sz; i ++) {
                TreeNode cur = queue.poll();

                if (height % 2 != 0) {
                    // 奇数行
                    line.addLast(cur.val);
                }
                else {
                    // 偶数行
                    line.addFirst(cur.val);
                }

                if (cur.left != null) {
                    queue.offer(cur.left);
                }
                if (cur.right != null) {
                    queue.offer(cur.right);
                }
            }
            res.add(line);
            height ++;
        }

        return res;
    }
}
```

## CD174/LC98. 判断一棵二叉树是否为搜索二叉树和完全二叉树

【题目链接】：

- NowCoder：[CD174. 判断一棵二叉树是否为搜索二叉树和完全二叉树](https://www.nowcoder.com/practice/4e271d590b564a61a03d04c5d9c6b6e3?tpId=101&tqId=33242&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- LeetCode：[98. 验证二叉搜索树 — Medium](https://leetcode-cn.com/problems/validate-binary-search-tree/)

【题目描述】：

给定一棵二叉树，已经其中没有重复值的节点，请判断该二叉树是否为搜索二叉树和完全二叉树。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

ps:节点的标号就是节点的值
```

输出描述:

```
第一行输出该二叉树是否为搜索二叉树的答案，如果是则输出 "true"，否则输出 "false"。

第二行输出该二叉树是否为完全二叉树的答案，如果是则输出 "true"，否则输出 "false"。
```

示例1

```
输入
3 2
2 1 3
1 0 0
3 0 0

输出
true
true
```

【解题思路】：

判断搜索二叉树 `isBST`：根据搜索二叉树的中序遍历的结果是升序的这一特点，如果出现降序或者相等，就直接返回 false

判断完全二叉树 `isCBT`：完全二叉树的结点编码是连续的，根据层次遍历，把所有结点依次入队（包括空结点），若空结点之后还有非空结点，就不是完全二叉树

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        TreeNode root = createTree(sc);

        System.out.println(isBST(root));
        System.out.println(isCBT(root));

    }

    // 判断是否是搜索二叉树 (中序遍历)
    private static boolean isBST(TreeNode root) {
        if (root == null) {
            return true;
        }

        Stack<TreeNode> stack = new Stack<>(); // 辅助栈
        TreeNode cur = root; // 工作指针
        TreeNode pre = null; // 中序遍历的前驱节点
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            else {
                cur = stack.pop();

                if (pre != null && pre.val >= cur.val) {
                    return false;
                }

                pre = cur;

                cur = cur.right;
            }
        }

        return true;
    }

    // 判断是否是完全二叉树 (层次遍历)
    private static boolean isCBT(TreeNode root) {
        if (root == null) {
            return true;
        }

        Queue<TreeNode> queue = new LinkedList<>(); // 辅助队列
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode cur = queue.poll();
            // 不管节点左右孩子是否为空，统统入队
            if (cur != null) {
                queue.offer(cur.left);
                queue.offer(cur.right);
            }
            // 遇到空节点之后剩余的应当全是空节点
            else { // cur == null
                while (!queue.isEmpty()) {
                    if (queue.poll() != null) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
}
```

## CD162. 打印二叉树的边界节点

【题目链接】：

- NowCoder：[CD161. 实现二叉树先序，中序和后序遍历](https://www.nowcoder.com/practice/566f7f9d68c24691aa5abd8abefa798c?tpId=101&tqId=33229&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一颗二叉树的根节点 root，按照如下两种标准分别实现二叉树的边界节点的逆时针打印。

标准一：

1，根节点为边界节点。

2，叶节点为边界节点。

3，如果节点在其所在的层中是最左的或最右的，那么该节点也是边界节点。

标准二：

1，根节点为边界节点。

2，叶节点为边界节点。

3，树左边界延伸下去的路径为边界节点。

4，树右边界延伸下去的路径为边界节点。

ps: 具体请对照样例

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
输出两行整数分别表示按两种标准的边界节点。
```

示例 1:

<img src="https://gitee.com/veal98/images/raw/master/img/20210418153718.png" style="zoom:80%;" />

```
输入
16 1
1 2 3
2 0 4
4 7 8
7 0 0
8 0 11
11 13 14
13 0 0
14 0 0
3 5 6
5 9 10
10 0 0
9 12 0
12 15 16
15 0 0
16 0 0
6 0 0

输出
1 2 4 7 11 13 14 15 16 12 10 6 3
1 2 4 7 13 14 15 16 10 6 3
```

【解题思路】：

对于标准一：

![](https://gitee.com/veal98/images/raw/master/img/20210418154232.png)

对于标准二：

![](https://gitee.com/veal98/images/raw/master/img/20210418154416.png)

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行不重要
        TreeNode root = createTree(sc);

        List<Integer> edge1 = printEdge1(root);
        for (int i : edge1) {
            System.out.print(i + " ");
        }

        System.out.println();

        List<TreeNode> edge2 = new ArrayList<>();
        printEdge2(root, edge2);
        for (TreeNode node : edge2) {
            System.out.print(node.val + " ");
        }
    }

    // 按照标准一输出边界
    private static List<Integer> printEdge1(TreeNode root) {
        List<Integer> res = new ArrayList<>(); // 存储结果
        if (root == null) {
            return res;
        }

        int height = getHeight(root); // 获取二叉树高度
        // 存储每层的最左和最右节点
        // edgeMap[i][0] 表示第 i 层的最左节点
        // edgeMap[i][1] 表示第 i 层的最右节点
        TreeNode[][] edgeMap = new TreeNode[height][2];
        setEdgeMap(root, 0, edgeMap);

        // 打印左边界
        for (int i = 0; i < edgeMap.length; i ++) {
            res.add(edgeMap[i][0].val);
        }

        // 打印既不是左边界也不是右边界的叶子节点
        List<TreeNode> leafNotInMapList = new ArrayList<>();
        getLeafNotInMap(root, 0, edgeMap, leafNotInMapList);
        for (TreeNode node : leafNotInMapList) {
            res.add(node.val);
        }

        // 打印右边界(自下向上),但不是左边界的节点
        for (int i = edgeMap.length-1; i >= 0; i --) {
            if (edgeMap[i][0] != edgeMap[i][1]) {
                res.add(edgeMap[i][1].val);
            }
        }

        return res;
    }

    // 递归获取二叉树高度
    private static int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        if (root.left == null && root.right == null) {
            return 1;
        }

        int leftHeight = getHeight(root.left);
        int rightHeight = getHeight(root.right);

        return Math.max(leftHeight, rightHeight) + 1;
    }

    /**
     * 递归存储每层的最左和最右节点
     * @param root
     * @param h 第几层
     * @param edgeMap
     */
    private static void setEdgeMap(TreeNode root, int h, TreeNode[][] edgeMap) {
        if (root == null) {
            return ;
        }

        edgeMap[h][0] = (edgeMap[h][0] == null) ? root : edgeMap[h][0];
        edgeMap[h][1] = root;

        setEdgeMap(root.left, h + 1, edgeMap);
        setEdgeMap(root.right, h + 1, edgeMap);
    }

    // 获取既不是左边界也不是右边界的叶子节点
    private static void getLeafNotInMap(TreeNode root, int h, TreeNode[][] edgeMap, List<TreeNode> leafNotInMapList) {
        if (root == null) {
            return ;
        }

        if (root.left == null && root.right == null &&
            root != edgeMap[h][0] && root != edgeMap[h][1]) {
            leafNotInMapList.add(root);
        }

        getLeafNotInMap(root.left, h + 1, edgeMap, leafNotInMapList);
        getLeafNotInMap(root.right, h + 1, edgeMap, leafNotInMapList);

    }


    // 按照标准二输出边界
    private static void printEdge2(TreeNode root, List<TreeNode> edgeList) {
        if (root == null) {
            return ;
        }

        edgeList.add(root); // 头节点符合标准二的要求

        if (root.left != null && root.right != null) {
            // 打印左边界的延伸路径，以及 root 左子树上所有的叶节点
            List<TreeNode> leftEdgeList = new ArrayList<>();
            getLeftEdge(root.left, true, leftEdgeList);
            for (TreeNode node : leftEdgeList) {
                edgeList.add(node);
            }
            // 打印右边界的延伸路径，以及 root 右子树上所有的叶节点
            List<TreeNode> rightEdgeList = new ArrayList<>();
            getRightEdge(root.right, true, rightEdgeList);
            for (TreeNode node : rightEdgeList) {
                edgeList.add(node);
            }
        }
        else {
            printEdge2((root.left != null) ? root.left : root.right, edgeList);
        }
    }

    private static void getLeftEdge(TreeNode root, boolean print, List<TreeNode> leftEdgeList) {
        if (root == null) {
            return ;
        }

        // 叶子节点
        if (print == true || (root.left == null && root.right == null)) {
            leftEdgeList.add(root);
        }

        getLeftEdge(root.left, print, leftEdgeList);
        getLeftEdge(root.right, (print == true && root.left == null) ? true : false, leftEdgeList);
    }

    private static void getRightEdge(TreeNode root, boolean print, List<TreeNode> rightEdgeList) {
        if (root == null) {
            return ;
        }

        getRightEdge(root.left, (print == true && root.right == null) ? true : false, rightEdgeList);
        getRightEdge(root.right, print, rightEdgeList);

        // 叶子节点
        if (print || (root.left == null && root.right == null)) {
            rightEdgeList.add(root);
        }
    }

}
```

## CD163/LC297/SO37. 二叉树的序列化和反序列化

【题目链接】：

- NowCoder：[CD163. 二叉树的序列化和反序列化](https://www.nowcoder.com/practice/d6425eab86fc402085f9fafc0db97cc2?tpId=101&tqId=33231&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- 剑指 Offer ：[剑指 Offer 37. 序列化二叉树 — Hard](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)
- LeetCode：[297. 二叉树的序列化与反序列化 — Hard](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)
- 牛客题霸.：[序列化二叉树](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=117&tqId=37782&companyId=134&rp=1&ru=%2Fcompany%2Fhome%2Fcode%2F134&qru=%2Fta%2Fjob-code-high%2Fquestion-ranking&tab=answerKey)

【题目描述】：

二叉树被记录为文件的过程叫作二叉树的序列化，通过文件内容重建原来二叉树的过程叫作二叉树的反序列化，给定一颗二叉树，请将该二叉树先序序列化和层序序列化。

假设序列化的结果字符串为 str，初始时 str = ""，遍历二叉树时，遇到 null 节点，则在 str 的末尾加上 "#!"，否则加上"当前的节点值!"。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
输出两行分别表示该二叉树的先序序列化和层序序列化
```

示例1

```
输入
2 1
1 2 0
2 0 0

输出
1!2!#!#!#!
1!2!#!#!#!
```

【解题思路】：

1）利用**先序遍历**来序列化和反序列化（这种比较好理解）

先序遍历的反序列化其实就是重做先序遍历，遇到 "#" 就生成 null 节点，结束生成后续子树的过程。

```java
	// 序列化 - 先序遍历
    private static String serializeByPre(TreeNode root) {
        if (root == null) {
            return "#!";
        }

        StringBuilder res = new StringBuilder(); // 存储序列化后的结果
        res.append(root.val).append("!");

        res.append(serializeByPre(root.left));
        res.append(serializeByPre(root.right));

        return res.toString();
    }
    // 反序列化 - 先序遍历
    private static TreeNode desrializeByPre(String str) {
        // 拆分字符串并一一入队
        String[] values = str.split("!");
        Queue<String> queue = new LinkedList<>();
        for (int i = 0; i < values.length; i ++) {
            queue.offer(values[i]);
        }

        return reconPreOrder(queue);
    }
    private static TreeNode reconPreOrder(Queue<String> queue) {
        // 每次弹出一个节点进行判断
        String value = queue.poll();
        if (value.equals("#")) { // 当前节点为空
            return null;
        }
        // 总是根据首位元素确定当前子树的根
        TreeNode root = new TreeNode(Integer.parseInt(value));
        root.left = reconPreOrder(queue);
        root.right = reconPreOrder(queue);

        return root;
    }
```

2）利用**层次遍历**来序列化和反序列化


与根据先序遍历的反序列化过程一样，根据层遍历的反序列化是重做层遍历，遇到 "#" 就生成 null 节点，同时不把 null 节点放到队列里即可。

```java
	// 序列化 - 层序遍历
    private static String serializeByLevel(TreeNode root) {
        if (root == null) {
            return "#!";
        }

        StringBuilder res = new StringBuilder(); // 存储序列化后的结果
        Queue<TreeNode> queue = new LinkedList<>(); // 辅助队列
        queue.offer(root);

        while (!queue.isEmpty()) {
            int currentLevelSize = queue.size();
            for (int i = 0; i < currentLevelSize; i ++) {
                TreeNode node = queue.poll();
                if (node == null) {
                    res.append("#!");
                }
                else { // node != null
                    res.append(node.val).append("!");

                    queue.offer(node.left);
                    queue.offer(node.right);
                }
            }
        }

        return res.toString();
    }
    // 反序列化 - 层序遍历
    private static TreeNode desrializeByLevel(String str) {
        String[] values = str.split("!");
        int index = 0; // values 数组的下标

        Queue<TreeNode> queue = new LinkedList<>(); // 辅助队列

        TreeNode root = generateTreeNodeByString(values[index ++]);
        if (root != null) {
            queue.offer(root);
        }

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            node.left = generateTreeNodeByString(values[index ++]);
            if (node.left != null) {
                queue.offer(node.left);
            }
            node.right = generateTreeNodeByString(values[index ++]);
            if (node.right != null) {
                queue.offer(node.right);
            }
        }

        return root;
    }
    private static TreeNode generateTreeNodeByString(String val) {
        if (val.equals("#")) {
            return null;
        }
        return new TreeNode(Integer.parseInt(val));
    }
```

## CD164. 遍历二叉树的神级方法

【题目链接】：

- NowCoder：[CD164. 遍历二叉树的神级方法](https://www.nowcoder.com/practice/5abcb95fe19d475a989dac3ba53e4635?tpId=101&tqId=33232&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一棵二叉树的头节点 head，完成二叉树的先序、中序和后序遍历。如果二叉树的节点数为 N，则要求时间复杂度为 O(N)，额外空间复杂度为 O(1)。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
输出三行分别表示二叉树的前序，中序和后序遍历。
```

示例1

```
输入
3 1
1 2 3
2 0 0
3 0 0

输出
1 2 3
2 1 3
2 3 1
```

【解题思路】：

本题真正的难点在于对复杂度的要求，尤其是额外空间复杂度为 O(1)的限制。之前的题目已经剖析过如何用递归和非递归的方法实现遍历二叉树，但是很不幸，之前所有的方法虽然常用，但都无法做到额外空间复杂度为 O(1)。

如果完全不用栈结构能完成三种遍历吗？答案是可以。方法是使用二叉树节点中大量指向 null 的指针，本题实际上就是大名鼎鼎的 **Morris 遍历**。

Morris 遍历的实质就是避免用栈结构，而是让下层到上层有指针，具体是通过**让底层节点指向 null 的空闲指针指回上层的某个节点，从而完成下层到上层的移动**。我们知道，二叉树上的很多节点都有大量的空闲指针，比如，某些节点没有右孩子节点，那么这个节点的 right 指针就指向 null，我们称为空闲状态，Morris 遍历正是利用了这些空闲指针。

先看看 Morris 遍历的过程：

假设当前节点为 cur，初始时 cur 就是整棵树的头节点，根据以下标准让 cur 移动：

- 如果 cur 为 null，则过程停止，否则继续下面的过程。
- 如果 cur 没有左子树，则让 cur 向右移动，即令 cur = cur.right。
- 如果 cur 有左子树，则找到 cur 左子树上最右的节点，记为 mostRight。
  - 如果 mostRight 的 right 指针指向 null，则令 mostRight.right = cur，也就是让 mostRight
    的 right 指针指向当前节点，然后让 cur 向左移动，即令 cur = cur.left。
  - 如果 mostRight 的 right 指针指向 cur，则令 mostRight.right = null，也就是让 mostRight
    的 right 指针指向 null，然后让 cur 向右移动，即令 cur = cur.right。

这里先给各位总结下：对于 Morris 遍历，有左子树的节点都可以到达两次，没有左子树的节点都只会到达一次。

举个例子：

![](https://gitee.com/veal98/images/raw/master/img/20210420205458.png)

![](https://gitee.com/veal98/images/raw/master/img/20210420205519.png)

上代码：

```java
// Morris 遍历
private static void morris(TreeNode root) {
    if (root == null) {
        return ;
    }

    TreeNode cur = root;
    TreeNode mostRight = null; // 当前节点左子树上的最右节点

    while (cur != null) {
        // 如果 cur 有左子树
        if (cur.left != null) {
            // 找到 cur 左子树上的最右节点
            mostRight = cur.left;
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            // 如果 mostRight.right 指向 null, 则让其指向 cur
            if (mostRight.right == null) {
                mostRight.right = cur;
                // cur 向左移动
                cur = cur.left;
            }
            // 如果 mostRight.right 指向 cur, 则让其指向 null
            else {
                mostRight.right = null;
                // cur 向右移动
                cur = cur.right;
            }
        }
        // 如果 cur 没有左子树
        else {
            // cur 向右移动
            cur = cur.right;
        }
    }
}
```

**可以根据 Morris 序进一步加工出先序、中序和后序**。

根据 Morris 遍历，加工出先序遍历：

- 对于 cur 只能到达一次的节点（无左子树的节点），cur 到达时直接打印。
- 对于 cur 可以到达两次的节点（有左子树的节点），cur 第一次到达时打印，第二次到达
  时不打印。

根据 Morris 遍历，加工出中序遍历：

- 对于 cur 只能到达一次的节点（无左子树的节点），cur 到达时直接打印。
- 对于 cur 可以到达两次的节点（有左子树的节点），cur 第一次到达时不打印，第二次到
  达时打印。

根据 Morris 遍历，加工出后序遍历：

- 对于 cur 只能到达一次的节点（无左子树的节点），直接跳过，没有打印行为。
- 对于 cur 可以到达两次的任何一个节点（有左子树的节点）X，cur 第一次到达 X 时没有
  打印行为；当第二次到达 X 时，逆序打印 X 左子树的右边界。
- cur 遍历完成后，逆序打印整棵树的右边界。

以图 3-9 来举例说明后序遍历的打印过程，这棵二叉树的 Morris 序为：4、2、1、2、3、4、6、5、6、7。

- 当第二次达到 2 时，逆序打印节点 2 左子树的右边界：1
- 当第二次达到 4 时，逆序打印节点 4 左子树的右边界：3、2
- 当第二次达到 6 时，逆序打印节点 6 左子树的右边界：5

cur 遍历完成后，逆序打印整棵树的右边界：7、6、4

可以看到这个顺序就是后序遍历的顺序。但是我们应该**如何实现逆序打印一棵树的右边界**？因为整个过程的额外空间复杂度要求是 O(1)，所以逆序打印一棵树右边界的过程中，是不能申请额外的数据结构的。为了更好地说明整个过程，下面举一个右边界比较长的例子，如图 3-14 所示：

![](https://gitee.com/veal98/images/raw/master/img/20210420205846.png)

假设 cur 第二次到达了 A，并且要逆序打印节点 A 左子树的右边界，首先将 E.R 指向 null，然后将右边界逆序调整成如图 3-15 所示的样子，**整个过程类似单链表的逆序操作**。

![](https://gitee.com/veal98/images/raw/master/img/20210420205904.png)

这样我们就可以从节点 E 开始，依次通过每个节点的 right 指针逆序打印整个左边界。在打印完 B 后，把右边界再逆序一次，调回来即可。

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        TreeNode root = createTree(sc);

        morrisPre(root);
        System.out.println();
        morrisIn(root);
        System.out.println();
        morrisPos(root);
        System.out.println();
    }

    // Morris 先序遍历
    private static void morrisPre(TreeNode root) {
        if (root == null) {
            return ;
        }

        TreeNode cur = root;
        TreeNode mostRight = null; // 当前节点左子树上的最右节点

        while (cur != null) {
            // 对于 cur 可以到达两次的节点（有左子树的节点），cur 第一次到达时打印，第二次到达时不打印
            if (cur.left != null) {
                mostRight = cur.left;
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }

                if (mostRight.right == null) { // 第一次到达
                    System.out.print(cur.val + " ");
                    mostRight.right = cur;
                    cur = cur.left;
                }
                else { // 第二次到达
                    mostRight.right = null;
                    cur = cur.right;
                }
            }
            // 对于 cur 只能到达一次的节点（无左子树的节点），cur 到达时直接打印。
            else {
                System.out.print(cur.val + " ");
                cur = cur.right;
            }
        }
    }

    // Morris 中序遍历
    private static void morrisIn(TreeNode root) {
        if (root == null) {
            return ;
        }

        TreeNode cur = root;
        TreeNode mostRight = null; // 当前节点左子树上的最右节点

        while (cur != null) {
            // 对于 cur 可以到达两次的节点（有左子树的节点），cur 第一次到达时不打印，第二次到达时打印
            if (cur.left != null) {
                mostRight = cur.left;
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }

                if (mostRight.right == null) { // 第一次到达
                    mostRight.right = cur;
                    cur = cur.left;
                }
                else { // 第二次到达
                    System.out.print(cur.val + " ");
                    mostRight.right = null;
                    cur = cur.right;
                }
            }
            // 对于 cur 只能到达一次的节点（无左子树的节点），cur 到达时直接打印。
            else {
                System.out.print(cur.val + " ");
                cur = cur.right;
            }
        }
    }

    // Morris 后序遍历
    private static void morrisPos(TreeNode root) {
        if (root == null) {
            return ;
        }

        TreeNode cur = root;
        TreeNode mostRight = null; // 当前节点左子树上的最右节点

        while (cur != null) {
            // 对于 cur 可以到达两次的任何一个节点（有左子树的节点）X，cur 第一次到达 X 时没有打印行为；
            // 当第二次到达 X 时，逆序打印 X 左子树的右边界
            if (cur.left != null) {
                mostRight = cur.left;
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }

                if (mostRight.right == null) { // 第一次到达
                    mostRight.right = cur;
                    cur = cur.left;
                }
                else { // 第二次到达
                    mostRight.right = null;
                    printEdge(cur.left); // 打印 cur 左子树的右边界
                    cur = cur.right;
                }
            }
            // 对于 cur 只能到达一次的节点（无左子树的节点），直接跳过，没有打印行为
            else {
                cur = cur.right;
            }
        }
        // cur 遍历完成后，逆序打印整棵树的右边界
        printEdge(root);
    }
    // 逆序打印某个节点的右边界
    private static void printEdge(TreeNode node) {
        TreeNode tail = reverseEdge(node);
        TreeNode cur = tail;
        while (cur != null) {
            System.out.print(cur.val + " ");
            cur = cur.right;
        }
        // 逆序之后记得把树结构恢复原状
        reverseEdge(tail);
    }

    // 逆序从 from 节点开始的右边界
    private static TreeNode reverseEdge(TreeNode from) {
        TreeNode pre = null;
        while (from != null) {
            TreeNode next = from.right; // 防止断链

            from.right = pre;
            pre = from;

            // 进入下一个节点的处理
            from = next;
        }
        return pre;
    }

}
```

## CD169. 找到搜索二叉树中两个错误的节点

【题目链接】：

- NowCoder：[CD169. 找到搜索二叉树中两个错误的节点](https://www.nowcoder.com/practice/9caad175642e4651a175e6993df9d8b2?tpId=101&tqId=33237&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得这棵二叉树不再是搜索二叉树，请按升序输出这两个错误节点的值。(每个节点的值各不相同)

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

ps:节点的编号就是该节点的值。
```

输出描述:

```
请按升序输出这两个错误节点的值。
```

示例1

```
输入
3 1
1 2 3
2 0 0
3 0 0

输出
1 2
```

【解题思路】：

根据**搜索二叉树（二叉排序树）的中序遍历的结果是升序的**这一特点，如果有两个节点位置错了，就一定会出现降序。

如果在中序遍历时节点值出现了两次降序，**第一个错误的节点为第一次降序时较大的节点，第二个错误的节点为第二次降序时较小的节点**。

比如，原来的搜索二叉树在中序遍历时的节点值依次出现 {1,2,3,4,5}，如果因为两个节点位置错了而出现 {1,5,3,4,2}，第一次降序为 5->3，所以第一个错误节点为 5，第二次降序为 4->2，所以第二个错误节点为 2，把 5 和 2 换过来就可以恢复。

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        TreeNode root = createTree(sc);

        TreeNode[] res = getTwoErrorNodes(root);
        System.out.print(res[1].val + " " + res[0].val);

    }

    private static TreeNode[] getTwoErrorNodes(TreeNode root) {
        TreeNode[] res = new TreeNode[2];

        if (root == null) {
            return res;
        }

        Stack<TreeNode> stack = new Stack<>(); // 辅助栈
        TreeNode cur = root; // 工作指针
        TreeNode pre = null; // 中序遍历的前驱节点
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            else {
                cur = stack.pop();

                if (pre != null && pre.val > cur.val) {
                    res[0] = (res[0] == null ? pre : res[0]);
                    res[1] = cur;
                }
                pre = cur;

                cur = cur.right;
            }
        }

        return res;
    }
}
```



## CD175. 在二叉树中找到一个节点的后继节点

【题目链接】：

- NowCoder：[CD175. 在二叉树中找到一个节点的后继节点](https://www.nowcoder.com/practice/c37ec6a9e4084b9c943be2d3a369e177?tpId=101&tqId=33243&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

二叉树中一个节点的后继节点指的是，二叉树的中序遍历的序列中的下一个节点。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行四个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

最后一行输入要询问的节点 node。
```

输出描述:

```
输出一个整数表示答案。(如果 node 是最后一个节点，则输出 0)
```

示例1

```
输入
10 6
6 3 9
3 1 4
1 0 2
2 0 0
4 0 5
5 0 0
9 8 10
10 0 0
8 7 0
7 0 0
10

输出
0
```

【解题思路】：

最简单的暴力解法，跑一遍二叉树的中序遍历，生成中序遍历序列，然后在这个序列中找到 node 节点的下一个节点返回即可。如果二叉树的节点数为 N，生成中序遍历的序列需要大小为 N 的数组空间，所以该方法的时间复杂度与额外空间复杂度都为 O(N)。这里就不写了，无脑复制粘贴就行了

最优解法不必遍历所有的节点，如果 node 节点和 node 后继节点之间的实际距离为 L，最优解法只用走过 L 个节点，时间复杂度为 O(L)，额外空间复杂度为 O(1)。接下来详细说明最优解法是如何找到 node 的后继节点的。

1）情况 1：如果 node 有右子树，那么 node 的后继节点就是右子树上最左边的节点。

2）情况 2：如果 node 没有右子树，

- 那么先看 node 是不是 node 父节点的左孩子节点，如果是左孩子节点，那么此时 node 的父节点就是 node 的后继节点；

- 如果是右孩子节点，就向上寻找 node 的后继节点，假设向上移动到的节点记为 s，s 的父节点记为 p，如果发现 s 是 p 的左孩子节点，那么节点 p 就是 node 节点的后继节点，否则就一直向上移动。

  简单来说，就是如果 node 没有右子树且是右孩子节点，就向上找到第一个是左孩子节点的节点。

那么，需要注意的是，**向上移动这个怎么做到呢**？

我们需要小小的修改下二叉树的结构，添加一个 `parent` 指针指向当前节点的父节点，以实现向上移动这个操作。

当然，同样的，构建二叉树的代码也同样做稍微的修改。

```java
	// 构建二叉树
    private static TreeNode createTree(Scanner sc, TreeNode parent) {
        String[] values = sc.nextLine().split(" ");
        if (values.length < 3) {
            return null;
        }

        int value = Integer.parseInt(values[0]);
        int left = Integer.parseInt(values[1]);
        int right = Integer.parseInt(values[2]);

        TreeNode root = new TreeNode(value);
        root.parent = parent;
        if (left != 0) {
            root.left = createTree(sc, root);
        }
        if (right != 0) {
            root.right = createTree(sc, root);
        }

        return root;
    }

    // 定义二叉树
    static class TreeNode {
        private int val;
        private TreeNode left;
        private TreeNode right;
        private TreeNode parent; // 父节点

        public TreeNode (int val) {
            this.val = val;
            this.left = null;
            this.right = null;
            this.parent = null;
        }
    }
```

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        // 构建二叉树
        TreeNode root = createTree(sc, null);
        // 在树上找到值为 target 的节点
        TreeNode node = findNode(root, sc.nextInt());
		// 输出 target 的后继节点
        System.out.println(getNextNode(node).val);

    }

    // 找到 node 的后继节点
    private static TreeNode getNextNode(TreeNode node) {
        if (node == null) {
            return node;
        }
        // 如果 node 有右子树，那么 node 的后继节点就是右子树上最左边的节点
        if (node.right != null) {
            return getLeftMost(node.right);
        }
        // 如果 node 没有右子树且是右孩子节点，就向上找到第一个是左孩子节点的节点。
        else { // node.right == null
            TreeNode parent = node.parent;
            while (parent != null && parent.left != node) {
                node = parent;
                parent = node.parent;
            }
            return parent;
        }
    }
    // 找到 node 子树上最左边的节点
    private static TreeNode getLeftMost(TreeNode node) {
        if (node == null) {
            return node;
        }

        while (node.left != null) {
            node = node.left;
        }

        return node;
    }

    // 在 root 树上找到值为 target 的节点
    private static TreeNode findNode(TreeNode root, int target) {
        if (root == null || root.val == target) {
            return root;
        }

        TreeNode left = findNode(root.left, target);
        TreeNode right = findNode(root.right, target);

        return left != null ? left : right;
    }
    
}
```

## LC114. 二叉树展开为链表

【题目链接】：

- LeetCode：[114. 二叉树展开为链表 — Medium](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

【题目描述】：

给你二叉树的根结点 root ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null
- 展开后的单链表应该与二叉树 先序遍历 顺序相同

示例 1：

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```


示例 2：

```
输入：root = []
输出：[]
```


示例 3：

```
输入：root = [0]
输出：[0]
```

【解题思路】：

1）方法一：

最容易想到的暴力解法就是先序遍历一遍二叉树，用一个 list 存储遍历的结果，然后根据遍历结果重新构造二叉树（链表）

```java
class Solution {
    public void flatten(TreeNode root) {
        List<TreeNode> preOrderList = preOrder(root);
        
        TreeNode cur = root;
        // 注意这里遍历从下标 1 开始(因为下标 0 是根节点)
        for (int i = 1; i < preOrderList.size(); i ++) {
            cur.left = null;
            cur.right = preOrderList.get(i);
            cur = cur.right;
        }
    }
    
    // 先序遍历
    private List<TreeNode> preOrder(TreeNode root) {
        ......
    }
}
```

2）方法二：

> 参考 [详细通俗的思路分析，多解法 - 二叉树展开为链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/)

两步完成这道题：

- **将左子树插入到右子树的地方**
- **将原来的右子树接到左子树的最右边节点**
- 考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null

可以看图理解下这个过程：

```java
    1
   / \
  2   5
 / \   \
3   4   6

// 将 1 的左子树插入到右子树的地方
    1
     \
      2         5
     / \         \
    3   4         6        
// 将原来的右子树接到左子树的最右边节点
    1
     \
      2          
     / \          
    3   4  
         \
          5
           \
            6
            
 // 将 2 的左子树插入到右子树的地方
    1
     \
      2          
       \          
        3       4  
                 \
                  5
                   \
                    6   
        
 // 将原来的右子树接到左子树的最右边节点
    1
     \
      2          
       \          
        3      
         \
          4  
           \
            5
             \
              6         
  
  ......

```

具体代码如下：

```java
class Solution {
    public void flatten(TreeNode root) {
        while (root != null) {
            // 左子树 == null
            if (root.left == null) {
                // 直接进入下一个节点的判断
                root = root.right;
            }
            // 左子树 != null
            else {
                // 记录 root 左子树的最右节点
                TreeNode pre = root.left;
                while (pre.right != null) {
                    pre = pre.right;
                }
                
                // 将原来的右子树接到左子树的最右节点的右子树上
                pre.right = root.right;
                
                // 使用左子树代替原先右子树的位置
                root.right = root.left;
                root.left = null;
                
                // 进入下一个节点的判断
                root = root.right;
            }
        }
    }
}
```

两种方法的对比：

<img src="https://gitee.com/veal98/images/raw/master/img/20210519165408.png" style="zoom:67%;" />

## 递归问题

### LC104/SO55. 二叉树的高度/深度

【题目链接】：

- LeetCode：[104. 二叉树的最大深度 — Easy](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
- 剑指 Offer：[55 - I. 二叉树的深度 — Easy](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

【题目描述】：

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：

```
给定二叉树 [3,9,20,null,null,15,7]，
    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 
```

【具体代码】：

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null)
            return 0;
        if(root.left == null && root.right == null)
            return 1;
        
        int left = maxDepth(root.left); // 左子树的高度
        int right = maxDepth(root.right); // 右子树的高度
        
        return (left > right ? left : right) + 1;
    }
}
```

### LC222/CD. 完全二叉树的节点个数

【题目链接】：

- LeetCode：[222. 完全二叉树的节点个数 — Medium](https://leetcode-cn.com/problems/count-complete-tree-nodes/)
- NowCoder：书中有这道题，但是牛客网上没有该题的链接

【题目描述】：

给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。

完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

示例 1：

```
输入：root = [1,2,3,4,5,6]
输出：6
```


示例 2：

```
输入：root = []
输出：0
```


示例 3：

```
输入：root = [1]
输出：1
```

【解题思路】：

直接套二叉树的递归模板是非常简单的：

```java
public int countNodes(TreeNode root) {
    if (root == null){
        return 0;
    }
    return countNodes(root.left) + countNodes(root.right) + 1;
}
```

但是没有利用好完全二叉树的特点。

首先需要明确完全二叉树的定义：它是一棵空树或者它的叶子节点只出在最后两层，若最后一层不满则叶子节点只在最左侧。

**突破点就在右子树的高度**，这里我们将整个树的高度记为 height：

1）如果右子树的高度等于 height - 1，说明左子树是满二叉树，可以直接通过公式 `2^(height-1)-1 `计算左子树的节点个数，不需要全部遍历。而对于右子树，由于不是满二叉树，没有公式可以直接计算，所以继续通过递归的方式计算右子树的节点个数。

> 图片来源：[java 代码，图文详解，击败了100%的用户 - 完全二叉树的节点个数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/javadai-ma-tu-wen-xiang-jie-ji-bai-liao-100de-yong/)

![image.png](https://pic.leetcode-cn.com/1606181328-pnpWQz-image.png)

2）如果右子树的高度不等于 height-1，说明右子树是满二叉树，其高度一定是 `height-2`，也可以通过公式 `2^(height-2)-1` 来计算右子树的节点个数。同样的，由于左子树不是满二叉树，没有公式可以直接计算，所以继续通过递归的方式计算左子树的节点个数。

![image.png](https://pic.leetcode-cn.com/1606182693-IsjHzh-image.png)

【具体代码】：

这里有个小技巧：

对于  `2^left`，可以使用位运算 `1 << left` 代替加快运算速度。

一开始我写出来的代码是这样的：

```java
class Solution {
    public int countNodes(TreeNode root) {
        int height = getHeight(root); // 树高
        
        // 如果树是空的
        if (height == 0 || height == 1) {
            return height;
        }
        
        // 如果右子树高 = 整体树高 - 1
        // 说明左子树是满二叉树, 节点个数为 2^(height-1) - 1
        // 左子树节点数 + 右子树节点数 + 1 = 总结点数
        if (getHeight(root.right) == height - 1) {
            return (1 << (height - 1)) + countNodes(root.right);
        }
        // 如果右子树高 != 整体树高 - 1
        // 说明右子树是满二叉树，右子树高 = 整体树高 - 2
        else {
            return (1 << (height - 2)) + countNodes(root.left);
        }
    }
    
    // 计算树高
    private int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        if (root.left == null && root.right == null) {
            return 1;
        }
        
        int leftHeight = getHeight(root.left);
        int rightHeight = getHeight(root.right);
        
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```

上述代码是可以 AC 的，但是其实还有一个小问题。

就是这个树高，有必要通过不断地递归左右子树来计算吗？

考虑完全二叉树的特性，左子树的高度一定是大于右子树，所以只需要考虑左子树就行了。

具体求完全二叉树高的代码如下：

```java
// 计算完全二叉树高
private int getHeight(TreeNode root) {
    if (root == null) {
        return 0;
    }
    if (root.left == null && root.right == null) {
        return 1;
    }

    int leftHeight = getHeight(root.left);

    return leftHeight + 1;
}
```

优化后的执行结果对比：

<img src="https://gitee.com/veal98/images/raw/master/img/20210519153940.png" style="zoom:67%;" />



### CD167. 找到二叉树中符合搜索二叉树条件的最大拓扑结构

【题目链接】：

- NowCoder：[CD167. 找到二叉树中符合搜索二叉树条件的最大拓扑结构](https://www.nowcoder.com/practice/e13bceaca5b14860b83cbcc4912c5d4a?tpId=101&tqId=33235&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一颗二叉树，已知所有节点的值都不一样， 返回其中最大的且符合搜索二叉树条件的最大拓扑结构的大小。

拓扑结构是指树上的一个联通块。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

ps:节点的编号就是节点的值。
```

输出描述:

```
输出一个整数表示满足条件的最大拓扑结构的大小。
```

示例1

```
输入
3 2
2 1 3
1 0 0
3 0 0

输出
3
```

【解题思路】：

整体思路是递归求解：

- 首先获取以 root 为头节点的树中，拓扑结构也以 root 为头节点的最大拓扑结构的节点数
- 然后递归获取 root 左子树的最大拓扑结构的节点数
- 再递归获取 root 右子树的最大拓扑结构的节点数
- 最后返回这三个结果中的最大值就行了

该方法详细见下述的 `bstTopoSize`

那么，**如何获取以 h 为头节点的树中，拓扑结构以 n 为头节点的最大拓扑结构的节点数呢？**

同样也是递归：

- 首先需要判断节点 n 能不能够加入以 h 作为头节点的二叉搜索树
- 然后递归获取以 h 为头节点的树中，拓扑结构以 n.left 为头节点的最大拓扑结构的节点数
- 再递归获取以 h 为头节点的树中，拓扑结构以 n.right 为头节点的最大拓扑结构的节点数
- 最后返回上述左右子数的结果 + 1 就行了

该方法详细见下述的 `maxTopo`

那么问题又来了，**如何判断节点 n 能不能够加入以 h 作为头节点的二叉搜索树中呢？**

这个问题有一种比较容易理解的解法，我们依次考查 h 的孩子节点，根据孩子节点的值从 h 开始按照二叉搜索的方式移动（如果孩子节点的值 < h 的值，则进入 h 的左子树查询；如果孩子节点的值 > h 的值，则进入 h 的右子树查询），如果最后能移动到孩子节点 n上，说明这个孩子节点 n 可以作为这个拓扑的一部分。

该方法详细见下述的 `isBSTNode`

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        TreeNode root = createTree(sc);

        System.out.println(bstTopoSize(root));
    }

    // 获取 root 为根节点的二叉树上的最大拓扑结构的节点树
    private static int bstTopoSize(TreeNode root) {
        if (root == null) {
            return 0;
        }

        // 获取以 root 为头节点的树中，拓扑结构也以 root 为头节点的最大拓扑结构的节点数
        int max = maxTopo(root, root);
        // 递归获取 root 左子树的最大拓扑结构的节点数
        max = Math.max(bstTopoSize(root.left), max);
        // 递归获取 root 右子树的最大拓扑结构的节点数
        max = Math.max(bstTopoSize(root.right), max);

        return max;
    }

    // 以 h 这个节点为头节点的子树中，拓扑结构以 n 为头节点，求其最大拓扑结构的节点数
    private static int maxTopo(TreeNode h, TreeNode n) {
        if (h != null && n != null && isBSTNode(h, n)) {
            return maxTopo(h, n.left) + maxTopo(h, n.right) + 1;
        }
        return 0;
    }

    // 判断节点 n 能否加入以 h 为 根节点的二叉搜索树中
    private static boolean isBSTNode(TreeNode h, TreeNode n) {
        if (h == null) {
            return false;
        }
        // 如果按照二叉搜索树的方式，h 能够遍历到 n，就说明 n 可以加入
        if (h == n) {
            return true;
        }

        return isBSTNode((h.val > n.val) ? h.left : h.right, n);
    }
}
```

时间复杂度分析：我们把所有的子树（N 个）都找了一次最大拓扑，每找一次，所考查的节点数都可能是 O(N) 个节点，所以方法一的时间复杂度为 O(N^2)

### CD170. 判断 t1 树是否包含 t2 树全部的拓扑结构

【题目链接】：

- NowCoder：[CD170. 判断 t1 树是否包含 t2 树全部的拓扑结构](https://www.nowcoder.com/practice/c9fe427263844505b82c6ebb7336d04a?tpId=101&tqId=33238&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定彼此独立的两棵二叉树，判断 t1 树是否包含 t2 树全部的拓扑结构。

设 t1 树的边集为 E1，t2 树的边集为 E2，若 E2 是 E1 的子集，则表示 t1 树包含 t2 树全部的拓扑结构。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树 t1 的总节点个数，root 表示二叉树 t1 的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

第 n+2 行输入两个整数 m 和 root，n 表示二叉树 t2 的总节点个数，root 表示二叉树 t2 的根节点。

以下 m 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
如果 t1 树包含 t2 树全部的拓扑结构，则输出 "true"，否则输出 "false"。
```

示例1

例如，如图 3-34 所示的 t1 树和如图 3-35 所示的 t2 树：

<img src="https://gitee.com/veal98/images/raw/master/img/20210425213937.png" style="zoom:67%;" />

示例2

> 牛客给出的示例输入有错，正确的应该下面这样

```
输入
10 1
1 2 3
2 4 5
4 8 9
8 0 0
9 0 0
5 10 0
10 0 0
3 6 7
6 0 0
7 0 0
4 2
2 4 5
4 8 0
8 0 0
5 0 0

输出
true
```

【解题思路】：

递归。

如果 t1 中某棵子树头节点的值与 t2 头节点的值一样，则从这两个头节点开始匹配，匹配的每一步都让 t1 上的节点跟着 t2 上的节点的先序遍历移动，每移动一步，都检查 t1 的当前节点是否与 t2 当前节点的值一样。

因此，如果 t1 的节点数为 N，t2 的节点数为 M，则该方法的时间复杂度为 O(N×M)。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine();
        TreeNode t1 = createTree(sc);
        sc.nextLine();
        TreeNode t2 = createTree(sc);
        System.out.println(contains(t1, t2));
    }

    // 判断 t1 是否包含 t2 全部的拓扑结构
    private static boolean contains(TreeNode t1, TreeNode t2) {
        if (t2 == null) {
            return true;
        }
        if (t1 == null) {
            return false;
        }

        return check(t1, t2) || contains(t1.left, t2) || contains(t1.right, t2);
    }

    // 当 t1.val 和 t2.val 相等时，判断 t1 是否包含 t2 全部的拓扑结构
    private static boolean check(TreeNode t1, TreeNode t2) {
        if (t2 == null) {
            return true;
        }
        if (t1 == null || t1.val != t2.val) {
            return false;
        }

        return check(t1.left, t2.left) && check(t1.right, t2.right);
    }

}
```

### CD171. 判断 t1 树中是否有与 t2 树拓扑结构完全相同的子树

【题目链接】：

- NowCoder：[CD171. 判断 t1 树中是否有与 t2 树拓扑结构完全相同的子树](https://www.nowcoder.com/practice/5a41ce17e8194e1688aa83a73137f7ee?tpId=101&tqId=33239&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定彼此独立的两棵二叉树，判断 t1 树是否有与 t2 树拓扑结构完全相同的子树。

设 t1 树的边集为 E1，t2 树的边集为 E2，若 E2 等于 E1 ，则表示 t1 树和t2 树的拓扑结构完全相同。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树 t1 的总节点个数，root 表示二叉树 t1 的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
第 n+2 行输入两个整数 m 和 root，n 表示二叉树 t2 的总节点个数，root 表示二叉树 t2 的根节点。
以下 m 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
如果 t1 树有与 t2 树拓扑结构完全相同的子树，则输出 "true"，否则输出 "false"。
```

示例 1

![](https://gitee.com/veal98/images/raw/master/img/20210425214339.png)

示例 2

```
输入
9 1
1 2 3
2 4 5
4 0 8
8 0 0
5 9 0
9 0 0
3 6 7
6 0 0
7 0 0
5 2
2 4 5
4 0 8
8 0 0
5 9 0
9 0 0

输出
true
```

【解题思路】：

1）方法一：

上面 <u>CD170. 判断 t1 树是否包含 t2 树全部的拓扑结构</u> 的答案完全可以照搬到这道题目来，不过时间复杂度时 O(N x M)，本题还有一种时间复度为 O(N + M) 的解法

2）方法二：

首先把 t1 树和 t2 树按照先序遍历的方式序列化，关于这个内容，可以参考 <u>CD163/LC297/SO37. 二叉树的序列化和反序列化</u>。以题目的例子来说，t1 树序列化后的结果为 “1!2!4!#!8!#!#!5!9!#!#!#!3!6!#!#!7!#!#!”，记为 t1Str。t2 树序列化后的结果为“2!4!#!8!#!#!5!9!#!#!#!”，记为 t2Str。

接下来，只要验证 t2Str 是否是 t1Str 的子串即可，这个用 KMP 算法可以在线性时间内解决。因此，t1 序列化的过程为 O(N)，t2 序列化的过程为O(M)，KMP 解决 t1Str 和 t2Str 的匹配问题 O(M+N)，所以时间复杂度为 O(M+N)。

### CD/LC108. 将有序数组转换为二叉搜索树

【题目链接】：

- NowCoder：通过有序数组生成平衡搜索二叉树
- LeetCode：[108. 将有序数组转换为二叉搜索树 — Easy](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

【题目描述】：

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

示例 1：

![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案
```

示例 2：

![img](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

```
输入：nums = [1,3]
输出：[3,1]
解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

【解题思路】：

其实就是通过中序遍历的结果来构建二叉树，直接递归处理。用有序数组中最中间的数生成搜索二叉树的头节点，然后用这个数左边的数生成左子树，用右边的数生成右子树即可。

【具体代码】：

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }
        return generate(nums, 0, nums.length - 1);
    }
    
    private TreeNode generate(int[] nums, int start, int end) {
        if (start > end) {
            return null;
        }
        
        int mid = (start + end) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = generate(nums, start, mid - 1);
        root.right = generate(nums, mid + 1, end);
        
        return root;
    }
}
```

### CD173. 根据后序数组重建搜索二叉树

【题目链接】：

- NowCoder：[CD173. 根据后序数组重建搜索二叉树](https://www.nowcoder.com/practice/f83d11c38a974cbc8973a10086be60f3?tpId=101&tqId=33241&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一个有 n 个不重复整数的数组 arr，判断 arr 是否可能是节点值类型为整数的搜索二叉树后序遍历的结果。

输入描述:

```
第一行一个整数 n，表示数组的长度。

第二行 n 个整数 arr_i。
```

输出描述:

```
如果是搜索二叉树后序遍历的结果则输出 "true"，否则输出 "false"。
```

示例1

```
输入
3
1 3 2

输出
true
```

【解题思路】：

递归。

后序遍历的最后一个节点就是根节点，根据搜索二叉树的性质，比后序数组最后一个元素值小的数组会在数组的左边，比数组最后一个元素值大的数组会在数组的右边。找到数组中左部分的结束位置和右部分的开始位置，然后再递归判断左右这两个部分是不是搜索二叉树。

比如，arr = [2,1,3,6,5,7,4]，比 4 小的部分为 [2,1,3]，比 4 大的部分为 [6,5,7]。如果不满足这种情况，则说明这个数组一定不可能是搜索二叉树后序遍历的结果。接下来，数组划分成左边数组和右边数组，相当于二叉树分出了左子树和右子树，只要继续递归地进行如上判断即可。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 数组的长度
        int[] arr = new int[n];
        for (int i = 0; i < n; i ++) {
            arr[i] = sc.nextInt();
        }

        System.out.println(isPostArray(arr));
    }

    private static boolean isPostArray(int[] arr) {
        if (arr == null || arr.length == 0) {
            return false;
        }
        return isPost(arr, 0, arr.length - 1);
    }

    private static boolean isPost(int[] arr, int start, int end) {
        // 只有一个节点
        if (start == end) {
            return true;
        }

        int less = -1; // 左部分的结束下标
        int more = end; // 右部分的开始下标

        int root = arr[end]; // 根节点

        for (int i = start; i < end; i ++) {
            // 找到左部分的结束下标
            if (root > arr[i]) {
                less = i;
            }
            // 找到右部分的开始下标
            else { // root <= arr[i]
                if (more == end) {
                    more = i;
                }
                // 可以简化成: more = (more == end) ? i : more;
            }
        }

        // 极端情况下二叉树退化成链表
        if (less == -1 || more == end) {
            return isPost(arr, start, end-1);
        }

        if (less + 1 != more) {
            return false;
        }

        return isPost(arr, start, less) && isPost(arr, more, end-1);
    }
}
```

【进阶问题】：

如果整型数组 arr 中没有重复值，且已知是一棵搜索二叉树的后序遍历结果，通过数组 arr 重构二叉树。

> 这道题目牛客网上没有链接，书中有。

和上述代码差不多，基本思路就是找到根节点、左部分的结束下标和右部分的开始下标，然后递归构建左右子树，就不细说了，直接上代码：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 数组的长度
        int[] postArr = new int[n];
        for (int i = 0; i < n; i ++) {
            postArr[i] = sc.nextInt();
        }

        System.out.println(isPostArray(postArr));
    }

    private static boolean postArrayToBST(int[] postArr) {
        if (postArr == null || postArr.length == 0) {
            return null;
        }
        return postToBST(postArr, 0, postArr.length - 1);
    }

    private static boolean postToBST(int[] arr, int start, int end) {
        if (start > end) {
            return null;
        }

        int less = -1; // 左部分的结束下标
        int more = end; // 右部分的开始下标

        TreeNode root = new TreeNode(postArr[end]); // 根节点

        for (int i = start; i < end; i ++) {
            // 找到左部分的结束下标
            if (root.val > postArr[i]) {
                less = i;
            }
            // 找到右部分的开始下标
            else { // root.val <= postArr[i]
                if (more == end) {
                    more = i;
                }
                // 可以简化成: more = (more == end) ? i : more;
            }
        }

        root.left = postToBST(arr, start, less);
        root.right = postToBST(arr, more, end - 1);

        return root;
    }
}
```

### CD187/LC337. 派对的最大快乐值（打家劫舍 III）

【题目链接】：

- NowCoder：[CD187. 派对的最大快乐值](https://www.nowcoder.com/practice/a5f542742fe24181b28f7d5b82e2e49a?tpId=101&tqId=33255&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- LeetCode：[337. 打家劫舍 III — Medium](https://leetcode-cn.com/problems/house-robber-iii/)

【题目描述】：

整个公司的人员结构可以看作是一棵标准的多叉树。树的头节点是公司唯一的老板，除老板外，每个员工都有唯一的直接上级，叶节点是没有任何下属的基层员工，除基层员工外，每个员工都有一个或多个直接下级，另外每个员工都有一个快乐值。

这个公司现在要办 party，你可以决定哪些员工来，哪些员工不来。但是要遵循如下的原则：

1. 如果某个员工来了，那么这个员工的所有直接下级都不能来。

2. 派对的整体快乐值是所有到场员工快乐值的累加。

3. 你的目标是让派对的整体快乐值尽量大。

给定一棵多叉树，请输出派对的最大快乐值。

输入描述:

```
第一行两个整数 n 和 root，n 表示公司的总人数，root 表示公司的老板。

第二行 n 个整数 happy_i 表示员工 i 的快乐值。

接下来 n - 1 行每行两个整数 u_i 和 v_i 表示 u_i 是 v_i 的直接上级。
```

输出描述:

```
输出一个整数表示最大快乐值。
```

示例1

```
输入
3 1
5 1 1
1 2
1 3

输出
5
```

【解题思路】：递归

首先，定义下员工的类：

```java
static class Employee {
    private int happy; // 这名员工可以带来的欢乐值
    private List<Employee> subordinates; // 这名员工的直接下级

    public Employee (int happy, List<Employee> subordinates) {
        this.happy = happy;
        this.subordinates = subordinates;
    }
}
```

假设以 X 为头节点的整棵树如图所示：

<img src="https://gitee.com/veal98/images/raw/master/img/20210517120426.png" style="zoom:50%;" />


X有a、b、c三个直接下级，a、b、c再往下一级的关系在图中已经省略。现在分析以 X 为头节点的整棵树，最大快乐值如何得到。情况只有两种:

- 一种为 X 来的情况下，整棵树的最大快乐值，记为 `yes_X_max`；
- 另一种为 X 不来的情况下，整棵树的最大快乐值，记为 `no_X_max`

据此，我们定义下返回值的结构

```java
// 每棵树处理完之后的返回值类型
static class ReturnData {
    private int yesHeadMax; // 树的头节点来的情况下，整棵树的最大收益
    private int noHeadMax; // 树的头节点不来的情况下，整棵树的最大收益

    public ReturnData (int yesHeadMax, int noHeadMax) {
        this.yesHeadMax = yesHeadMax;
        this.noHeadMax = noHeadMax;
    }
}
```

详细分析如下：

<img src="https://gitee.com/veal98/images/raw/master/img/20210517120720.png" style="zoom: 67%;" />

yes_X_max和no_X_max哪个大，哪个就是X为头节点的整棵树的最大快乐值。

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 公司的总人数
        int boss = sc.nextInt(); // 公司老板

        // 员工列表 (key: 下标, 从 1 开始)
        Map<Integer, Employee> map = new HashMap<>();

        // 设置员工的欢乐值
        for (int i = 1; i <= n; i ++) {
            Employee employee = new Employee(sc.nextInt(), new ArrayList<>());
            map.put(i, employee);
        }

        // 设置直接下级
        for (int i = 0; i < n-1; i ++) {
            Employee em = map.get(sc.nextInt()); // 上级
            Employee sub = map.get(sc.nextInt()); // 直接下级
            em.subordinates.add(sub); // 设置上下级关系
        }

        System.out.println(getMaxHappy(map.get(boss)));

    }

    private static int getMaxHappy (Employee boss) {
        ReturnData allTreeInfo = process(boss);
        return Math.max(allTreeInfo.yesHeadMax, allTreeInfo.noHeadMax);
    }

    // 递归处理以 X 为头节点的树，并且返回 X 来和不来两种情况下的最大快乐值
    private static ReturnData process (Employee X) {
        int yesX = X.happy; // X来的情况下，一定要累加上 X 自己的快乐值
        int noX = 0; // X 不来的情况下，不累加上 X 自己的快乐值

        // 如果 X 没有直接下属，说明 X 是基层员工
        if (X.subordinates.isEmpty()) {
            return new ReturnData(yesX, noX);
        }
        // 如果 X 有直接下属，分两种情况讨论(X 来; X 不来)
        else {
            for (Employee next : X.subordinates) {
                // 递归处理 X 的直接下属 next，获取 next 来或不来的欢乐值
                ReturnData subTreeInfo = process(next);
                // 1. X 来，则 X 的直接下属 next 不能来
                yesX += subTreeInfo.noHeadMax;
                // 2. X 不来，X 的直接下属 next 可以来
                // next 来或不来取决于 next 来的欢乐值是否大于 next 不来的欢乐值
                noX += Math.max(subTreeInfo.yesHeadMax, subTreeInfo.noHeadMax);
            }
            return new ReturnData(yesX, noX);
        }
    }

    // 每棵树处理完之后的返回值类型
    static class ReturnData {
        private int yesHeadMax; // 树的头节点来的情况下，整棵树的最大收益
        private int noHeadMax; // 树的头节点不来的情况下，整棵树的最大收益

        public ReturnData (int yesHeadMax, int noHeadMax) {
            this.yesHeadMax = yesHeadMax;
            this.noHeadMax = noHeadMax;
        }
    }

    static class Employee {
        private int happy; // 这名员工可以带来的欢乐值
        private List<Employee> subordinates; // 这名员工的直接下级

        public Employee (int happy, List<Employee> subordinates) {
            this.happy = happy;
            this.subordinates = subordinates;
        }
    }

}
```

LeetCode 上的 [337. 打家劫舍 III — Medium](https://leetcode-cn.com/problems/house-robber-iii/) 和这道题完全一样，就是题目描述变了而已，整体的意思都是一样的，就是如果一个节点来了（被打劫了），那么它的直接子节点就不能来了（不能被打劫了）。

看下题目描述：

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

示例 1:

```
输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
```

解题代码也是基本一样，只不过由于输入中包含 null，所以需要加个 null 节点的判断：

```java
class Solution {
    public int rob(TreeNode root) {
        ReturnData allTreeInfo = process(root);
        return Math.max(allTreeInfo.yesHeadMax, allTreeInfo.noHeadMax);
    }
    
    private ReturnData process(TreeNode X) {
        if (X == null) {
            return new ReturnData(0, 0);
        }
        
        int yesX = X.val;
        int noX = 0;
        
        if (X.right == null && X.left == null) {
            return new ReturnData(yesX, noX);
        }
        else {
            TreeNode[] suboridates = new TreeNode[] {X.left, X.right};
            for (TreeNode next : suboridates) {
                // 递归处理 X 的直接下属 next，获取 next 来或不来的欢乐值
                ReturnData subTreeInfo = process(next);
                // 1. X 来，则 X 的直接下属 next 不能来
                yesX += subTreeInfo.noHeadMax;
                // 2. X 不来，X 的直接下属 next 可以来
                // next 来或不来取决于 next 来的欢乐值是否大于 next 不来的欢乐值
                noX += Math.max(subTreeInfo.yesHeadMax, subTreeInfo.noHeadMax);
            }
            return new ReturnData(yesX, noX);
        }
        
    }
    
    class ReturnData {
        private int yesHeadMax; // 树的头节点来的情况下，整棵树的最大收益
        private int noHeadMax; // 树的头节点不来的情况下，整棵树的最大收益

        public ReturnData (int yesHeadMax, int noHeadMax) {
            this.yesHeadMax = yesHeadMax;
            this.noHeadMax = noHeadMax;
        }
    }
}
```



### CD180. 通过先序和中序数组生成后序数组

【题目链接】：

- NowCoder：[CD180. 通过先序和中序数组生成后序数组](https://www.nowcoder.com/practice/5ae5174f17674e458028ce12bc8bfe0b?tpId=101&tqId=33248&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给出一棵二叉树的先序和中序数组，通过这两个数组直接生成正确的后序数组。

输入描述:

```
第一行一个整数 n，表示二叉树的大小。

第二行 n 个整数 a_i，表示二叉树的先序遍历数组。

第三行 n 个整数 b_i，表示二叉树的中序遍历数组。
```

输出描述:

```
输出一行 n 个整数表示二叉树的后序遍历数组。
```

示例1

```
输入
3
1 2 3
2 1 3 

输出
2 3 1 
```

【解题思路】：

递归。通过前序遍历的结果去中序遍历中找到这个节点的左右子树，然后递归构建二叉树。

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 二叉树节点个数
        int[] preOrderList = new int[n];
        int[] inOrderList = new int[n];
        for (int i = 0; i < n; i ++) {
            preOrderList[i] = sc.nextInt();
        }
        for (int i = 0; i < n; i ++) {
            inOrderList[i] = sc.nextInt();
        }

        TreeNode root = reConstructBinaryTree(preOrderList, inOrderList);
        List<Integer> postOrderList = postOrder(root);
        for (int i : postOrderList) {
            System.out.print(i + " ");
        }

    }

    // 根据先序遍历和中序遍历，构建二叉树
    private static TreeNode reConstructBinaryTree(int[] preOrderList, int[] inOrderList) {
        if (preOrderList.length == 0 || inOrderList.length == 0) {
            return null;
        }


        TreeNode root = new TreeNode(preOrderList[0]); // 根节点
        // 在中序遍历序列中找到根节点
        for (int i = 0; i < inOrderList.length; i ++) {
            if (inOrderList[i] == root.val) {
                root.left = reConstructBinaryTree(
                        Arrays.copyOfRange(preOrderList, 1, i + 1),
                        Arrays.copyOfRange(inOrderList, 0, i)
                );
                root.right = reConstructBinaryTree(
                        Arrays.copyOfRange(preOrderList, i + 1, preOrderList.length),
                        Arrays.copyOfRange(inOrderList, i + 1, inOrderList.length)
                );
            }
        }

        return root;
    }


    // 后序遍历
    private static List<Integer> postOrder(TreeNode root) {
        ......
    }
}
```

### CD182/LC95. 不同的二叉搜索树 II

【题目链接】：

- LeetCode：[95. 不同的二叉搜索树 II — Medium](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)
- NowCoder：书中这道题目的进阶题：统计和生成所有不同的二叉树，不过在 NowCoder 平台上这道进阶题对应的 [CD182. 统计和生成所有不同的二叉树](https://www.nowcoder.com/practice/3975b2a794ee419aa927b24f6495c7d6?tpId=101&tqId=33249&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey) 题目描述是错误的（和 CD181 完全一样，一个字没改，我佛了）。

【题目描述】：

给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。

 示例 1：

![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
输入：n = 3
输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
```


示例 2：

```
输入：n = 1
输出：[[1]]
```

【解题思路】：

递归。

进阶问题与原问题【CD181/LC96. 不同的二叉搜索树】的过程其实很类似。

如果要生成中序遍历是 {a…b} 的所有结构，就从 a 开始一直到 b，枚举每一个值作为头节点，把每次生成的二叉树结构的头节点都保存下来即可。假设其中一次是以 i 值为头节点的（a≤i≤b），以 i 为头节点的所有结构按如下步骤生成。

1. 用 {a…i-1} 递归生成左子树的所有结构，假设所有结构的头节点保存在 lSubs 线性表中。
2. 用 {a…i+1} 递归生成右子树的所有结构，假设所有结构的头节点保存在 rSubs 线性表中。
3. 在以 i 为头节点的前提下，lSubs 中的每一种结构都可以与 rSubs  中的每一种结构构成单独的结构，且和其他任何结构都不同。为了保证所有的结构之间不互相交叉，所以对每一种结构都复制出新的树，并记录在总的链表 res 中。

【具体代码】：

```java
class Solution {
    public List<TreeNode> generateTrees(int n) {
        return generate(1,n);
    }
    
    private List<TreeNode> generate(int start, int end) {
        List<TreeNode> res = new ArrayList<>();
        if (start > end) {
            res.add(null);
        }
        
        TreeNode root = null;
        for (int i = start; i <= end; i ++) {
            // 以 i 作为头节点
            root = new TreeNode(i);
            // 左子树的所有结构
            List<TreeNode> lSubs = generate(start, i - 1);
            // 右子树的所有结构
            List<TreeNode> rSubs = generate(i + 1, end);
            
            for (TreeNode l : lSubs) {
                for (TreeNode r : rSubs) {
                    root.left = l;
                    root.right = r;
                    res.add(cloneTree(root));
                }
            }
        }
        
        return res;
    }
    
    // 复制一棵树
    private TreeNode cloneTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        
        TreeNode res = new TreeNode(root.val);
        res.left = cloneTree(root.left);
        res.right = cloneTree(root.right);
        
        return res;
    }
}
```

### LC538. 把二叉搜索树转换为累加树

【题目链接】：

- LeetCode：[538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

【题目描述】：

给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

示例 1：

```
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```


示例 2：

```
输入：root = [0,null,1]
输出：[1,null,1]
```


示例 3：

```
输入：root = [1,0,2]
输出：[3,3,2]
```


示例 4：

```
输入：root = [3,2,4,1]
输出：[7,9,4,10]
```

【解题思路】：

本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。这样我们只需要**反序中序遍历**该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。

【具体代码】：

```java
class Solution {
    
    int sum = 0;
    
    public TreeNode convertBST(TreeNode root) {
        if (root != null) {
            convertBST(root.right);
        
            sum += root.val;
            root.val = sum;

            convertBST(root.left);
        }
        
        return root;
    }
}
```



## 树形 DP 问题

**树形 dp 套路使用前提：如果题目求解目标是 S，则求解流程可以定成分别以每一个节点作为头节点的子树在目标 S 下的每一个答案，并且最终答案一定在其中。**

### CD166. 找到二叉树中的最大搜索二叉子树

【题目链接】：

- NowCoder：[CD166. 找到二叉树中的最大搜索二叉子树](https://www.nowcoder.com/practice/380d49d7f99242709ab4b91c36bf2acc?tpId=101&tqId=33234&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一颗二叉树，已知其中所有节点的值都不一样，找到含有节点最多的搜索二叉子树，**输出该子树总节点的数量**。

搜索二叉树是指对于二叉树的任何一个节点，如果它有儿子，那么左儿子的值应该小于它的值，右儿子的值应该大于它的值。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

ps:节点的编号就是节点的值。
```

输出描述:

```
1 <= n <= 1000000
1 <= fa,lch,rch,root <= n
```

示例1

```
输入
3 2
2 1 3
1 0 0
3 0 0

输出
3
```

【解题思路】：

题目求解目标是：整棵二叉树中的最大搜索二叉子树，这就是我们的目标。那么求解流程可以定成：在整棵二叉树中，求出以每一个节点作为头节点的子树的最大搜索二叉子树（对任何一棵子树都求出答案），并且最终答案（整棵二叉树的最大搜索二叉子树）一定在其中。

**树形 dp 套路第一步：以某个节点 X 为头节点的子树中，分析答案有哪些可能性，并且这种分析是以 X 的左子树、X 的右子树和 X 整棵树的角度来考虑可能性的。**

用本题举例。以节点 X 为头节点的子树中，最大的搜索二叉子树只可能是以下三种情况中可能性最大的那种。

- 第一种：X 为头节点的子树中，最大的搜索二叉子树就是 X 的左子树中的最大搜索二叉子树。也就是说，答案可能来自左子树。比如，本例中，当 X 为节点 12 时。
- 第二种：X 为头节点的子树中，最大的搜索二叉子树就是 X 的右子树中的最大搜索二叉子树。也就是说，答案可能来自右子树。比如，本例中，当 X 为节点 6 时。
- 第三种：如果 X 左子树上的最大搜索二叉子树是 X 左子树的全体，X 右子树上的最大搜索二叉子树是 X 右子树的全体，并且 X 的值大于 X 左子树所有节点的最大值，但小于 X 右子树所有节点的最小值，那么 X 为头节点的子树中，最大的搜索二叉子树就是以 X 为头节点的全体。也就是说，答案可能是用 X 连起所有。比如，本例中，当 X 为节点 10 时。

**树形 dp 套路第二步：根据第一步的可能性分析，列出所有需要的信息。**

用本题举例，为了分析第一、二种可能性，需要分别知道左子树和右子树上的最大搜索二叉子树的头部，记为 `leftMaxBSTHead`、`rightMaxBSTHead`，因为要比较大小，所以还需要分别知道左子树和右子树上的最大搜索二叉子树的大小，记为 `leftBSTSize`、`rightBSTSize`，并且有了这些信息还能帮助分析第三种可能性，因为如果知道了 leftMaxBSTHead，并且发现它正好是 X 的左孩子节点，则说明 X左子树上的最大搜索二叉子树是 X 左子树的全体。同理，可以利用 rightMaxBSTHead 来判断 X 右子树上的最大搜索二叉子树是否为 X 右子树的全体。

但是有这些还不够，因为第三种可能性还要求 X 的值大于 X 左子树所有节点的最大值，但小于 X 右子树所有节点的最小值。因此，需要从左子树上取得左子树的最大值 `leftMax`，从右子树上取得右子树的最小值 `rightMin`。汇总一下，为了分析所有的可能性，左树上需要的信息为：leftMaxBSTHead、leftBSTSize、leftMax；右树上需要的信息为：rightMaxBSTHead、rightBSTSize、rightMin。

**树形 dp 套路第三步：合并第二步的信息，对左树和右树提出同样的要求，并写出信息结构。**

以本题举例，左树和右树都需要最大搜索二叉子树的头节点及其大小这两个信息，但是左树只需要最大值，右树只需要最小值，那么合并变成统一要求。信息结构请看如下的 `ReturnType` 类。

```java
// 封装左右子树所需要的信息
class ReturnType {
    private TreeNode maxBSTHead; // 最大搜素树的根节点
    private int maxBSTSize; // 最大搜索树中节点的个数
    private int min; // 搜索树中节点的最小值
    private int max; // 搜索树中节点的最大值

    public ReturnType(TreeNode maxBSTHead, int maxBSTSize, int min, int max) {
        this.maxBSTHead = maxBSTHead;
        this.maxBSTSize = maxBSTSize;
        this.min = min;
        this.max = max;
    }
}
```

**树形 dp 套路第四步：设计递归函数，递归函数是处理以 X 为头节点的情况下的答案，包括设计递归的 base case，获取左树和右树的所有信息，以及把可能性做整合，并且要返回第三步的信息结构这四个小步骤。**

本题的实现请看如下的 process 方法。

【具体代码】：

```java
import java.util.Scanner;

public class CD166 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        TreeNode root = createTree(sc);

        System.out.println(getMaxBst(root));
    }

    // 获取最大搜索子树的节点总数
    private static int getMaxBst(TreeNode root) {
        return process(root).maxBSTSize;
    }
    private static ReturnType process(TreeNode X) {
        // base case
        if (X == null) {
            return new ReturnType(null, 0, Integer.MAX_VALUE, Integer.MIN_VALUE);
        }

        // 获取左子树的信息
        ReturnType lData = process(X.left);
        // 获取右子树的信息
        ReturnType rData = process(X.right);

        int min = Math.min(X.val, Math.min(lData.min, rData.min));
        int max = Math.max(X.val, Math.max(lData.max, rData.max));

        // 最大搜索树在 X 的左子树或者右子树中
        TreeNode maxBSTHead = lData.maxBSTSize >= rData.maxBSTSize ? lData.maxBSTHead : rData.maxBSTHead;
        int maxBSTSize = Math.max(lData.maxBSTSize, rData.maxBSTSize);

        // 最大搜索树的根节点就是 X 本身
        if (lData.maxBSTHead == X.left && rData.maxBSTHead == X.right &&
            X.val > lData.max && X.val < rData.min) {
            maxBSTHead = X;
            maxBSTSize = lData.maxBSTSize + rData.maxBSTSize + 1;
        }

        return new ReturnType(maxBSTHead, maxBSTSize, min, max);
    }

    // 封装左右子树所需要的信息
    static class ReturnType {
        private TreeNode maxBSTHead; // 最大搜素树的根节点
        private int maxBSTSize; // 最大搜索树中节点的个数
        private int min; // 搜索树中节点的最小值
        private int max; // 搜索树中节点的最大值

        public ReturnType(TreeNode maxBSTHead, int maxBSTSize, int min, int max) {
            this.maxBSTHead = maxBSTHead;
            this.maxBSTSize = maxBSTSize;
            this.min = min;
            this.max = max;
        }
    }
}
```

### CD172/LC110. 判断二叉树是否为平衡二叉树

【题目链接】：

- NowCoder：[CD172. 判断二叉树是否为平衡二叉树](https://www.nowcoder.com/practice/0d7b90d3cf454062942ff9376e1c8b7e?tpId=101&tqId=33240&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- LeetCode：[110. 平衡二叉树 — Easy](https://leetcode-cn.com/problems/balanced-binary-tree/)

【题目描述】：

平衡二叉树的性质为: 要么是一棵空树，要么任何一个节点的左右子树高度差的绝对值不超过 1。给定一棵二叉树，判断这棵二叉树是否为平衡二叉树。

一颗树的高度指的是树的根节点到所有节点的距离中的最大值。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
如果是平衡二叉树则输出 "true"，否则输出 "false"。
```

示例1

```
输入
3 1
1 2 3
2 0 0
3 0 0

输出
true
```

示例2

```
输入
6 1
1 2 3
2 4 5
4 6 0
3 0 0
5 0 0
6 0 0

输出
false
```

【解题思路】：

首先，树形 dp 套路的前提是满足的。依次考查每个节点为头节点的子树，如果都是平衡二叉树，那么整体就是平衡二叉树。

**树形 dp 套路第一步：以某个节点 X 为头节点的子树中，分析答案有哪些可能性，并且这种分析是以 X 的左子树、X 的右子树和 X 整棵树的角度来考虑可能性的。**

- 可能性一：如果 X 的左子树不是平衡的，则以 X 为头节点的树就是不平衡的。
- 可能性二：如果 X 的右子树不是平衡的，则以 X 为头节点的树就是不平衡的。
- 可能性三：如果 X 的左子树和右子树高度差超过 1，则以 X 为头节点的树就是不平衡的。
- 可能性四：如果上面可能性都没中，那么以 X 为头节点的树是平衡的。

**树形 dp 套路第二步：根据第一步的可能性分析，列出所有需要的信息。**

左子树和右子树都需要知道各自是否平衡，以及高度这两个信息。

**树形 dp 套路第三步：合并第二步的信息，对左树和右树提出同样的要求，并写出信息结构。**

```java
static class ReturnType {
    private int height;
    private boolean isBalanced;

    public ReturnType(int height, boolean isBalanced) {
        this.height = height;
        this.isBalanced = isBalanced;
    }
}
```

**树形 dp 套路第四步：设计递归函数，递归函数是处理以 X 为头节点的情况下的答案，包括设计递归的 base case，获取左树和右树的所有信息，以及把可能性做整合，并且要返回第三步的信息结构这四个小步骤。**

本题的递归实现请看以下的 process 方法，主函数是以下的 isBalanced 方法。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine();
        TreeNode root = createTree(sc);
        System.out.println(process(root).isBalanced);
    }

    private static ReturnType process(TreeNode root) {
        if (root == null) {
            return new ReturnType(0, true);
        }

        ReturnType leftData = process(root.left);
        ReturnType rightData = process(root.right);

        int height = Math.max(leftData.height, rightData.height) + 1;
        boolean isBalanced = leftData.isBalanced && rightData.isBalanced &&
                             Math.abs(leftData.height - rightData.height) < 2;
        return new ReturnType(height, isBalanced);
    }

    static class ReturnType {
        private int height;
        private boolean isBalanced;

        public ReturnType(int height, boolean isBalanced) {
            this.height = height;
            this.isBalanced = isBalanced;
        }
    }
}
```

### CD179/LC543. 二叉树中的最大距离

【题目链接】：

- NowCoder：[CD179. 二叉树节点间的最大距离问题](https://www.nowcoder.com/practice/88331be6da0d40749b068586dc0a2a8b?tpId=101&tqId=33247&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- LeetCode：[543. 二叉树的直径 — Easy](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

【题目描述】：

从二叉树的节点 A 出发，可以向上或者向下走，但沿途的节点只能经过一次，当到达节点 B 时，**<u>路径上的节点数</u>叫作 A 到 B 的距离**。

现在给出一棵二叉树，求整棵树上每对节点之间的最大距离。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
最后一行为节点 o1 和 o2。
```

输出描述:

```
输出一个整数表示答案。
```

示例1

```
输入
7 1
1 2 3
2 4 5
4 0 0
5 0 0
3 6 7
6 0 0
7 0 0

输出
5
```

【解题思路】：

**树形 dp 套路第一步：以某个节点 X 为头节点的子树中，分析答案有哪些可能性，并且这种分析是以 X 的左子树、X 的右子树和 X 整棵树的角度来考虑可能性的。**

- 可能性一：以X为头节点的子树，最大距离可能是左子树上的最大距离。
- 可能性二：以X为头节点的子树，最大距离可能是右子树上的最大距离
- 可能性三：以X为头节点的子树，最大距离可能是从X的左子树离X最远的节点，先到达X，然后走到X的右子树离X最远的节点。<u>也就是左子树高度 + 右子树高度 + 1</u>。

**树形 dp 套路第二步：根据第一步的可能性分析，列出所有需要的信息。**

左子树和右子树都需要知道自己这棵子树上的最大距离，以及高度这两个信息。

**树形 dp 套路第三步：合并第二步的信息，对左树和右树提出同样的要求，并写出信息结构。**

```java
static class ReturnType {
    private int maxDistance; // 最大距离
    private int height; // 树高

    public ReturnType (int maxDistance, int height){
        this.maxDistance = maxDistance;
        this.height = height;
    }
}
```

**树形 dp 套路第四步：设计递归函数，递归函数是处理以 X 为头节点的情况下的答案，包括设计递归的 base case，获取左树和右树的所有信息，以及把可能性做整合，并且要返回第三步的信息结构这四个小步骤。**

本题的实现请看如下的 process 方法。

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine();
        TreeNode root = createTree(sc);
        System.out.println(getMaxDistance(root));
    }

    private static int getMaxDistance (TreeNode root) {
        return process(root).maxDistance;
    }

    private static ReturnType process (TreeNode root) {
        if (root == null) {
            return new ReturnType(0, 0);
        }

        ReturnType leftData = process(root.left);
        ReturnType rightData = process(root.right);

        // 以 root 为根节点的树的高度
        int height = Math.max(leftData.height, rightData.height) + 1;
        // 以 root 为根节点的树的最大距离
        int maxDistance = Math.max(Math.max(leftData.maxDistance, rightData.maxDistance),
                                   leftData.height + rightData.height + 1);

        return new ReturnType(maxDistance, height);
    }

    static class ReturnType {
        private int maxDistance; // 最大距离
        private int height; // 树高

        public ReturnType (int maxDistance, int height){
            this.maxDistance = maxDistance;
            this.height = height;
        }
    }
}
```

### LC124. 二叉树中的最大路径和

【题目链接】：

- LeetCode：[124. 二叉树中的最大路径和 — Hard](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

【题目描述】：

路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。

示例 1：

![img](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

示例 2：

![img](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

【解题思路】：

> 这道题目我暂时还不知怎么用左神的树形 DP 模板写，But 解题思路都是一样的，下面的代码是 LeetCode 官方的题解。

首先，我们需要理解**一个节点的最大贡献值**的意义，具体而言，就是**在以该节点为根节点的子树中寻找 <u>以该节点为起点</u> 的一条路径，使得该路径上的节点值之和最大**。

理解贡献值的含义很重要！

具体而言：

空节点的最大贡献值等于 0。

非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）。

例如，考虑如下二叉树。

```
   -10
   / \
  9  20
    /  \
   15   7
```

叶节点 9、15、7 的最大贡献值分别为 9、15、7。

得到叶节点的最大贡献值之后，再计算非叶节点的最大贡献值。节点 20 的最大贡献值等于 20+max(15,7)=35，节点 -10 的最大贡献值等于−10+max(9,35)=25。

得到每个节点的最大贡献值之后，如何得到二叉树的最大路径和？

**对于二叉树中的一个节点，该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值**，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。

维护一个全局变量 maxSum 存储最大路径和，在递归过程中更新 maxSum 的值，最后得到的 maxSum 的值即为二叉树中的最大路径和。

【具体代码】：

```java
class Solution {
    
    // 维护一个全局变量 maxSum 存储最大路径和
    private int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        return process(root).maxSum;
    }
    
    private ReturnType process(TreeNode root) {
        if (root == null) {
            return new ReturnType(0, 0);
        }
        
        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        ReturnType leftData = process(root.left);
        ReturnType rightData = process(root.right);
                                       
        int leftGain = Math.max(leftData.maxGain, 0);
        int rightGain = Math.max(rightData.maxGain, 0);  

        // 包含 root 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        maxSum = Math.max(maxSum, root.val + leftGain + rightGain);
        // root 节点的最大贡献值
        int maxGain = root.val + Math.max(leftGain, rightGain);
        
        return new ReturnType(maxSum, maxGain);
    }
    
    class ReturnType {
        private int maxSum; // 包含某个节点的最大路径和
        private int maxGain; // 某个节点的最大贡献值
        
        public ReturnType (int maxSum, int maxGain) {
            this.maxSum = maxSum;
            this.maxGain = maxGain;
        }
    }
}
```



## DP 问题

### CD181/LC96. 不同的二叉搜索树

【题目链接】：

- NowCoder：[CD181. 统计和生成所有不同的二叉树](https://www.nowcoder.com/practice/3975b2a794ee419aa927b24f6495c7d6?tpId=101&tqId=33249&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- LeetCode：[96. 不同的二叉搜索树 — Medium](https://leetcode-cn.com/problems/unique-binary-search-trees/)

【题目描述】：

给出一个整数 n，如果 n < 1，代表空树，否则代表**中序遍历**的结果为 {1, 2, 3... n}。请输出可能的二叉树结构有多少。

输入描述:

```
第一行输入一个整数 n。
```

输出描述:

```
输出一个整数对 1e9 + 7 取模的值表示答案。
```

示例 1：

![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
输入
3

输出
5
```

示例 2：

```
输入
7 

输出
429 
```

【解题思路】：

动态规划。

**辅助表** `dp[i]`：表示以 `1....i` 为节点组成的二叉搜索树有 `dp[i]` 种。我们要求的就是 `dp[n]`

**状态转移方程**：由题意可知，每个节点都有可能成为根节点，假设 `j` 为二叉搜索树 `1....i`  中的根节点，则：

`dp[i]` = `dp[j-1]` * `dp[i-j]`

<img src="https://gitee.com/veal98/images/raw/master/img/20201207173732.png" style="zoom:67%;" />

举例而言，创建以 3 为根、长度为 7 的不同二叉搜索树，整个序列是 `[1, 2, 3, 4, 5, 6, 7]`，我们需要从左子序列 `[1, 2]` 构建左子树，从右子序列 `[4, 5, 6, 7]` 构建右子树，然后将它们组合（即笛卡尔积）。

base case：`dp[0] = 1，dp[1] = 1`

注意 `dp[0] = 1`，否则 j = 1 的时候， `dp[j-1] = 0`，使得整个式子 `dp[i]` = `dp[j-1]` * `dp[i-j]` 都为 0，显然是错误的。

核心代码就是下面这样：

```java
private static int numTrees(int n) {
    // dp[i] 表示以 1....i 为节点组成的二叉搜索树有 dp[i] 种
    int[] dp = new int[n + 1];

    // base case
    dp[0] = 1;
    dp[1] = 1;

    // 状态转移方程
    for (int i = 2 ; i <= n; i ++) {
        // j 为二叉搜索树 1....i 中的根节点
        for (int j = 1 ; j <= i; j ++) {
            dp[i] += dp[j - 1] * dp[i - j];
        }
    }

    return dp[n];
}
```

【具体代码】：

由于题目要求需要对 1e9 + 7 取模的值作为答案，所以我们需要稍作修改：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.println(numTrees(n));
    }

    private static int numTrees(int n) {
        // dp[i] 表示以 1....i 为节点组成的二叉搜索树有 dp[i] 种
        long[] dp = new long[n + 1];

        // base case
        dp[0] = 1;
        dp[1] = 1;

        // 状态转移方程
        int mod = (int) (1e9 + 7);
        for (int i = 2 ; i <= n; i ++) {
            // j 为二叉搜索树 1....i 中的根节点
            for (int j = 1 ; j <= i; j ++) {
                dp[i] += (dp[j - 1] * dp[i - j]) % mod;
                dp[i] = dp[i] % mod;
            }
        }

        return (int) dp[n];
    }

}
```

注意辅助表用 long，不然中途如果发生溢出再取模就是个错误结果。

## 哈希表

### CD165. 在二叉树中找到累加和为指定值的最长路径长度

【题目链接】：

- NowCoder：[CD165. 在二叉树中找到累加和为指定值的最长路径长度](https://www.nowcoder.com/practice/2d35bc3364e3470381bc4eebd9178747?tpId=101&tqId=33233&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一颗二叉树和一个整数 sum，求累加和为 sum 的最长路径长度。路径是指从某个节点往下，每次最多选择一个孩子节点或者不选所形成的节点链。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行四个整数 fa，lch，rch，val，表示 fa 的左儿子为 lch，右儿子为 rch。val 表示 fa 节点的值(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
输出一个整数表示最长链的长度。
```

示例1

```
输入
9 1
1 2 3 -3
2 4 5 3
4 0 0 1
5 8 9 0
8 0 0 1
9 0 0 6
3 6 7 -9
6 0 0 2
7 0 0 1
6

输出
4
```

【解题思路】：

这题和【CD9. 未排序数组中累加和为给定值的最长子数组长度】的思路基本一致，不过有一点需要额外考虑。具体过程如下：

![](https://gitee.com/veal98/images/raw/master/img/20210421224955.png)

另外根据这里题目给出的数据格式，二叉树的构造也需要做一点点的改变

【具体代码】：

```java
public class CD165 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        TreeNode root = createTree(sc);
        int sum = sc.nextInt();
        System.out.print(getMaxLength(root, sum));
    }

    private static int getMaxLength(TreeNode root, int sum) {
        Map<Integer, Integer> sumMap = new HashMap<>();
        sumMap.put(0, 0);
        return preOrder(root, sum, 0, 1, 0, sumMap);
    }
    private static int preOrder(TreeNode root, int sum, int preSum, int level,
                                int maxLen, Map<Integer, Integer> sumMap) {
        if (root == null) {
            return maxLen;
        }

        int curSum = preSum + root.val;
        if (!sumMap.containsKey(curSum)) {
            sumMap.put(curSum, level);
        }

        if (sumMap.containsKey(curSum - sum)) {
            maxLen = Math.max(level - sumMap.get(curSum - sum), maxLen);
        }

        maxLen = preOrder(root.left, sum, curSum, level + 1, maxLen, sumMap);
        maxLen = preOrder(root.right, sum, curSum, level + 1, maxLen, sumMap);
        // 回退机制，在计算 cur 节点的左右子树时，如果其 cursum 是第一次出现，也就是 map 中的层数等于当前层数，
        // 那就说明这个累加和 curSum 是在遍历到 cur 时加上去的
        // 所以在我们回退到 cur 的父节点时，需要删除 map 中这条的记录
        if (sumMap.get(curSum) == level) {
            sumMap.remove(curSum);
        }

        return maxLen;
    }

    // 构建二叉树
    private static TreeNode createTree(Scanner sc) {
        String[] values = sc.nextLine().split(" ");
        if (values.length < 3) {
            return null;
        }

        int value = Integer.parseInt(values[3]);
        int left = Integer.parseInt(values[1]);
        int right = Integer.parseInt(values[2]);

        TreeNode root = new TreeNode(value);
        if (left != 0) {
            root.left = createTree(sc);
        }
        if (right != 0) {
            root.right = createTree(sc);
        }

        return root;
    }
}
```

### CD176. 在二叉树中找到两个节点的最近公共祖先

【题目链接】：

- NowCoder：[CD176. 在二叉树中找到两个节点的最近公共祖先](https://www.nowcoder.com/practice/c75deef6d4bf40249c785f240dad4247?tpId=101&tqId=33244&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一棵二叉树以及这棵树上的两个节点 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。 

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

最后一行为节点 o1 和 o2。
```

输出描述:

```
输出一个整数表示答案。
```

示例1

<img src="https://gitee.com/veal98/images/raw/master/img/20210506204758.png" style="zoom: 33%;" />

```
输入
8 1
1 2 3
2 4 5
4 0 0
5 0 0
3 6 7
6 0 0
7 8 0
8 0 0
4 5

输出
2
```

【解题思路】：

1）方法一：递归

**后序遍历二叉树**，假设遍历到的当前节点为 cur，先处理 cur 的两棵子树。假设处理 cur 左子树时返回节点为 left，处理右子树时返回节点为 right。

- 如果发现 cur 等于 null，或者 cur 就是 o1、o2，则直接返回 cur。
- 如果 left 和 right 都为空，说明 cur 整棵子树上没有发现过 o1 或 o2，返回 null。
- 如果 left 和 right 都不为空，说明在 cur 的左子树上发现过 o1 或 o2，右子树上也发现过 o2 或 o1，即 o1 和 o2 分居 cur 的左右两侧，cur 就是它们的最近公共祖先节点，返回 cur。
- 如果 left 和 right 有一个为空，另一个不为空，假设不为空的那个记为 node，此时有两种可能，要么 node 是 o1 或 o2 中的一个，要么 node 是 o1 和 o2 的最近公共祖先。当然，不管是哪种情况，直接返回 node 即可。 

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine();
        TreeNode root = createTree(sc);
        TreeNode o1 = findNode(root, sc.nextInt());
        TreeNode o2 = findNode(root, sc.nextInt());
        System.out.println(getLowestAncestor(root, o1, o2).val);
    }

    // 返回 o1 和 o2 的最近公共祖先节点（后序遍历）
    private static TreeNode getLowestAncestor(TreeNode root, TreeNode o1, TreeNode o2) {
        if (root == null || root == o1 || root == o2) {
            return root;
        }

        // 在当前节点的左右子树上分别查抄 o1 和 o2
        TreeNode left = getLowestAncestor(root.left, o1, o2);
        TreeNode right = getLowestAncestor(root.right, o1, o2);

        // 如果 left 和 right 都不为空，说明左子树上发现过o1或o2，右子树上也发现过o2或o1
        // 直接返回当前节点
        if (left != null && right != null) {
            return root;
        }

        return  left != null ? left : right;
    }

    // 在树上找到值为 target 的节点
    private static TreeNode findNode(TreeNode root, int target) {
        if (root == null || root.val == target) {
            return root;
        }

        TreeNode left = findNode(root.left, target);
        TreeNode right = findNode(root.right, target);

        return left != null ? left : right;
    }
}
```

这里多提一嘴，上述代码中，根据 o1 和 o2 节点的值去树中查找这俩节点的方式有点愚蠢，并且效率不高，可以直接做如下修改，将节点之间的比较改成值之间的比较就行了：

![](https://gitee.com/veal98/images/raw/master/img/20210506204649.png)

2）方法二：

如果查询两个节点的最近公共祖先的操作十分频繁的话，每次查询都来一遍递归显然效率是比较低下的。

为此，我们可以建立一个记录，以后每次执行查询时就根据这个记录来就行了。

**建立一张哈希表：key 代表二叉树中的一个节点，value 代表其对应的父节点**。

只用遍历一次二叉树，这张表就可以创建好，以后每次查询都可以根据这张哈希表进行即可。

![](https://gitee.com/veal98/images/raw/master/img/20210506211417.png)

假设想查节点 4 和节点 8 的最近公共祖先，方法是使用如上的哈希表，把包括节点 4 在内的所有节点 4 的祖先节点放进另一个哈希表 A 中，**A 表示节点 4 到头节点这条路径上所有节点的集合**。所以 A={节点4，节点2，节点1}。

然后使用如上的哈希表，从节点 8 开始往上逐渐移动到头节点。首先是节点 8，发现不在 A 中，然后是节点 7，发现也不在A中，接下来是节点3，依然不在A中，最后是节点1，发现在A中，那么节点1就是节点4和节点8的最近公共祖先。

只要在移动过程中发现某个节点在 A 中，这个节点就是题目要求的最近公共祖先节点。

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine();
        TreeNode root = createTree(sc);
        TreeNode o1 = findNode(root, sc.nextInt());
        TreeNode o2 = findNode(root, sc.nextInt());
        System.out.println(getLowestAncestor(root, o1, o2).val);
    }

    // 返回 o1 和 o2 的最近公共祖先节点（后序遍历）
    private static TreeNode getLowestAncestor(TreeNode root, TreeNode o1, TreeNode o2) {
        Record record = new Record(root);
        return record.query(o1, o2);
    }

    static class Record {
        private HashMap<TreeNode, TreeNode> map;

        public Record(TreeNode root) {
            map = new HashMap<>();
            // root 的父节点是 null
            if (root != null) {
                map.put(root, null);
            }
            // 遍历二叉树，建立记录
            setMap(root);
        }

        // 遍历二叉树，建立节点与其父节点的记录
        private void setMap(TreeNode root) {
            if (root == null) {
                return ;
            }

            if (root.left != null) {
                map.put(root.left, root);
            }
            if (root.right != null) {
                map.put(root.right, root);
            }

            setMap(root.left);
            setMap(root.right);
        }

        // 查询 o1 和 o2 的最近公共祖先节点
        private TreeNode query(TreeNode o1, TreeNode o2) {
            // 存储从 o1 到头节点的路径
            HashSet<TreeNode> path = new HashSet<>();
            while (map.containsKey(o1)) {
                path.add(o1);
                o1 = map.get(o1);
            }

            // 使用如上的哈希表，从节点 o2 开始往上逐渐移动到头节点
            while (!path.contains(o2)) {
                o2 = map.get(o2);
            }

            return o2;
        }
    }

    // 在树上找到值为 target 的节点
    private static TreeNode findNode(TreeNode root, int target) {
        if (root == null || root.val == target) {
            return root;
        }

        TreeNode left = findNode(root.left, target);
        TreeNode right = findNode(root.right, target);

        return left != null ? left : right;
    }
}
```

很明显，建立这种哈希表记录的过程时间复杂度为 O(N)、额外空间复杂度为 O(N)。进行查询操作时，时间复杂度为 O(h)，其中，h 为二叉树的高度。

### CD177. 在二叉树中找到两个节点的最近公共祖先(进阶)

【题目链接】：

- NowCoder：[CD177. 在二叉树中找到两个节点的最近公共祖先(进阶)](https://www.nowcoder.com/practice/357a9856c629405a8405d293bd6be2d1?tpId=101&tqId=33245&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一棵二叉树，多次给出这棵树上的两个节点 o1 和 o2，请对于每次询问，找到 o1 和 o2 的最近公共祖先节点。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

第 n+2 行输入一个整数 m，表示询问的次数。

以下 m 行每行两个节点 o1 和 o2。
```

输出描述:

```
对于每组询问每行输出一个整数表示答案。
```

示例1

```
输入
8 1
1 2 3
2 4 5
4 0 0
5 0 0
3 6 7
6 0 0
7 8 0
8 0 0
4
4 5
5 2
6 8
5 8

输出
2
2
3
1
```

【解题思路】：

这道题就是上述 CD176 的方法二，建立一个记录表。如果查询两个节点的最近公共祖先的操作十分频繁的话，每次查询都来一遍递归显然效率是比较低下的。

这里就不再多说了，除了 main 函数代码基本完全一样。

需要注意的是，我们同样拒绝使用上述的 findNode 按值查找节点的方法来构建 o1 和 o2 节点，在查询的时候直接根据值进行比较就行了。

> 这里注意下，**所有的二叉树算法题我们都默认没有重复值，节点之间的比较可以等同于值的比较**。这样可以在某种程度上优化时间复杂度。

【具体代码】：

```java
public class CD177 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine();
        TreeNode root = createTree(sc);

        int m = sc.nextInt();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < m; i ++) {
            Integer o1 = sc.nextInt();
            Integer o2 = sc.nextInt();
            sb.append(getLowestAncestor(root, o1, o2));
            sb.append("\n");
        }
        System.out.print(sb.toString());
    }

    // 返回 o1 和 o2 的最近公共祖先节点的值（后序遍历）
    private static Integer getLowestAncestor(TreeNode root, Integer o1, Integer o2) {
        Record record = new Record(root);
        return record.query(o1, o2);
    }

    static class Record {
        // key: 节点的值 value: 父节点的值
        private HashMap<Integer, Integer> map;

        public Record (TreeNode root){
            map = new HashMap<>();
            if (root != null) {
                map.put(root.val, null);
            }
            // 遍历二叉树，建立记录
            setMap(root);
        }

        // 遍历二叉树，建立节点与其父节点的记录
        private void setMap(TreeNode root) {
            if (root == null) {
                return ;
            }
            if (root.left != null) {
                map.put(root.left.val, root.val);
            }
            if (root.right != null) {
                map.put(root.right.val, root.val);
            }

            setMap(root.left);
            setMap(root.right);
        }

        // 查询 o1 和 o2 的最近公共祖先节点的值
        private Integer query(Integer o1, Integer o2) {
            // 存储从 o1 到头节点的路径
            HashSet<Integer> path = new HashSet<>();
            while (map.containsKey(o1)) {
                path.add(o1);
                o1 = map.get(o1);
            }

            // 使用如上的哈希表，从节点 o2 开始往上逐渐移动到头节点
            while (!path.contains(o2)) {
                o2 = map.get(o2);
            }

            return o2;
        }
    }
}

```

只能通过 75%，不知道为啥。