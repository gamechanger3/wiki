# 链表问题

---

## CD48. 打印两个升序链表具有相同值的部分

【题目链接】：

- NowCoder：[CD48. 打印两个升序链表的公共部分](https://www.nowcoder.com/practice/8943eea40dbb4185b187d80fd050fee9?tpId=101&tqId=33116&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定两个升序链表，打印两个升序链表的公共部分。（题意表述的不清楚，其实是打印出两个升序链表具有相同值的部分）

输入描述:

```
第一个链表的长度为 n。

第二个链表的长度为 m。

链表结点的值为 val。
```

输出描述:

```
输出一行整数表示两个升序链表的公共部分的值 (按升序输出)。
```

示例1

```
输入
4
1 2 3 4
5
1 2 3 5 6

输出
1 2 3
```

示例2

```
输入
3
1 3 6
3
3 4 6

输出
3 6
```

【解题思路】：

很简单吧，获取两个升序链表中具有相同值得元素，使用**归并**思想，从两个链表的头开始进行如下判断：

- 如果 head1 的值小于 head2，则 head1 往下移动。
- 如果 head2 的值小于 head1，则 head2 往下移动。
- 如果 head1 的值与 head2 的值相等，则打印这个值，然后 head1 与 head2 都往下移动。
- head1 或 head2 有任何一个移动到 null，则整个过程停止。

【具体代码】：

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 第一个链表的长度
        ListNode head1 = new ListNode(-1); // 第一个链表的头节点
        ListNode p = head1;
        for (int i = 0; i < n; i ++) {
            p.next = new ListNode(sc.nextInt());
            p = p.next;

        }
        int m = sc.nextInt(); // 第二个链表的长度
        ListNode head2 = new ListNode(-1); // 第二个链表的头节点
        ListNode q = head2;
        for (int i = 0; i < m; i ++) {
            q.next = new ListNode(sc.nextInt());
            q = q.next;
        }

        List<Integer> res = getCommonPart(head1.next, head2.next);
        for (int num : res) {
            System.out.print(num + " ");
        }
    }
    
    // 定义链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    private static List<Integer> getCommonPart(ListNode head1, ListNode head2) {
        List<Integer> res = new ArrayList<>();
        ListNode p = head1;
        ListNode q = head2;

        while (p != null && q != null) {
            if (p.val == q.val) {
                res.add(p.val);
                p = p.next;
                q = q.next;
            }
            else if (p.val < q.val) {
                p = p.next;
            }
            else { // p.val >= q.val
                q = q.next;
            }
        }

        return res;
    }
}
```

## CD106. 删除链表的第 K 个节点

【题目链接】：

- NowCoder：[删除链表的第 K 个节点](https://www.nowcoder.com/practice/0796dbf0eb054716937b0b82e0671c5f?tpId=101&tqId=33174&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一个链表，实现删除链表第 K 个节点的函数。

输入描述:

```
n 表示链表的长度。

m 表示删除链表第几个节点。

val 表示链表节点的值。
```

输出描述:

```
在给定的函数中返回链表的头指针。
```

示例1

```
输入
5 3
1 2 3 4 5

输出
1 2 4 5
```

【解题思路】：

没啥难度，找到第 k 个节点的前驱节点就行了

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 链表的长度
        int k = sc.nextInt(); // 第 k 个节点
        ListNode head = new ListNode(-1); // 头节点
        ListNode p = head;
        for (int i = 0; i < n; i ++) {
            p.next = new ListNode(sc.nextInt());
            p = p.next;
        }

        removeKthNode(head.next, k);

        ListNode q = head.next;
        while (q != null) {
            System.out.print(q.val + " ");
            q = q.next;
        }
    }

    // 定义链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    // 删除链表的倒数第 k 个元素
    private static ListNode removeKthNode(ListNode head, int k) {
        ListNode p = head;
        ListNode pre = head; // 前驱节点

        for (int i = 1; i < k; i ++) {
            pre = p;
            p = p.next;
        }

        // 删除第 k 个节点
        pre.next = p.next;

        return head;
    }
}
```



## CD49/LC19. 删除链表的倒数第 K 个节点

【题目链接】：

- NowCoder：[CD49. 在链表中删除倒数第 K 个节点](https://www.nowcoder.com/practice/e5d90aac4c8b4628aa70d9b6597c0560?tpId=101&tqId=33117&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- LeetCode：[19. 删除链表的倒数第 N 个节点 — Meidum](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

【题目描述】：

给出一个单链表，返回删除单链表的倒数第 K 个节点的链表。

输入描述:

```
n 表示链表的长度。
val 表示链表中节点的值。
```

输出描述:

```
在给定的函数内返回链表的头指针。
```

示例1

```
输入
5 4
1 2 3 4 5

输出
1 3 4 5
```

【解题思路】：

**快慢指针**。让快指针先走 `n` 步，然后快慢指针开始同速前进。这样当快指针走到链表最后一个元素时，慢指针所在的位置就是倒数第 `n` 个链表节点的前驱节点。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 链表的长度
        int k = sc.nextInt(); // 倒数第 k 个节点
        ListNode head = new ListNode(-1); // 头节点
        ListNode p = head;
        for (int i = 0; i < n; i ++) {
            p.next = new ListNode(sc.nextInt());
            p = p.next;
        }

        removeLastKthNode(head.next, k);

        ListNode q = head.next;
        while (q != null) {
            System.out.print(q.val + " ");
            q = q.next;
        }
    }

    // 定义链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    // 删除链表的倒数第 k 个元素
    private static ListNode removeLastKthNode(ListNode head, int k) {
        ListNode fast = head;
        ListNode slow = head;

        while (k > 0) {
            fast = fast.next;
            k --;
        }

        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        // 找到了倒数第 k 个节点的前驱节点
        ListNode kNode = slow.next;
        // 删除第 k 个节点
        slow.next = kNode.next;

        return head;
    }
}
```

## CD107. 反转单向链表和双向链表

【题目链接】：

- NowCoder：[CD107. 反转单向链表和双向链表](https://www.nowcoder.com/practice/b66a251dec8847f386bbe6cd96b7e9c8?tpId=101&tqId=33175&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

实现反转单向链表和双向链表的函数。

如 1->2->3 反转后变成 3->2->1。

输入描述:

```
第一行一个整数 n，表示单链表的长度。

第二行 n 个整数 val 表示单链表的各个节点。

第三行一个整数 m，表示双链表的长度。

第四行 m 个整数 val 表示双链表的各个节点。
```

输出描述:

```
在给定的函数内返回相应链表的头指针。
```

示例1

```
输入
3
1 2 3
4
1 2 3 4

输出
3 2 1
4 3 2 1
```

【解题思路】：

反转单向链表和反转双向链表的思路是一样的，只不过双向链表多处理一下 pre 指针罢了。

这里以单向链表为例，讲解一下反转链表的两种方法（这里很重要）：

⭐ 1）**第一种：新链表 + 头插法**

首先新建 newHead 节点作为新链表的头节点；然后使用头插法依次从原链表取下节点插入 newHead 的后面。最后返回 newHead.next 即可

![](https://gitee.com/veal98/images/raw/master/img/20210224233624.png)

```java
// 反转单链表 (使用头节点+新链表的方式)
private static ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }

    ListNode newHead = new ListNode(-1); // 新链表的头节点
    newHead.next = null;

    // 不断地把原链表的节点摘下来头插到新链表上
    while (head != null) {
        ListNode temp = head.next; // 防止断链

        // 头插法
        head.next = newHead.next;
        newHead.next = head;

        // 开始下一次循环
        head = temp;
    }

    return newHead.next;
}
```

> 这里提一嘴，如果没有采用新链表，而是直接在原链表上进行头插，记得一定要处理最后一个节点的 next 指针，防止成环，这个点我们在后面的题目会遇上的。

⭐ 2）**第二种：原地反转**

主要是利用两个辅助的结点，不断地循环更改指针的指向：

- preNode 和 next 分别代表当前要处理的节点的前一个结点和后一个结点
- 通过改变结点的 next 域的指向来反转整个链表，通过循环处理，每次反转一个之后，preNode 指向下一个结点，也就是 head，head 更改为 head 的下一个结点，也就是 next，这样直到 head 为空，返回 preNode 就反转了整个单链表

```java
public static ListNode reverseList(ListNode head){
      ListNode preNode = null;
      while(head != null) {
            ListNode next = head.next;
          
            head.next = preNode;
            preNode = head;
          
            head = next;
      }
      return pre;
}
```

【具体代码】：这里对于单链表我采用新链表 + 头插法的方式，对于双链表采用原地反转的方式。

```java
import java.util.Scanner;

public class CD107 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt(); // 单链表的长度
        ListNode head1 = new ListNode(sc.nextInt()); // 第一个元素节点
        ListNode p = head1;
        for (int i = 1; i < n; i ++) {
            p.next = new ListNode(sc.nextInt());
            p = p.next;
        }

        int m = sc.nextInt(); // 双链表的长度
        DoubleListNode head2 = new DoubleListNode(sc.nextInt()); // 第一个元素节点
        DoubleListNode q = head2;
        for (int i = 1; i < m; i ++) {
            DoubleListNode node = new DoubleListNode(sc.nextInt());
            q.next = node;
            node.pre = q;

            q = q.next;
        }

        // 反转单链表
        ListNode newHead1 = reverseList(head1);
        ListNode cur1 = newHead1;
        while (cur1 != null) {
            System.out.print(cur1.val + " ");
            cur1 = cur1.next;
        }

        System.out.println();

        // 反转双链表
        DoubleListNode newHead2 = reverseDoubleList(head2);
        DoubleListNode cur2 = newHead2;
        while (cur2 != null) {
            System.out.print(cur2.val + " ");
            cur2 = cur2.next;
        }

    }

    // 定义单链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    // 定义双链表结构
    public static class DoubleListNode {
        private int val;
        private DoubleListNode next;
        private DoubleListNode pre;

        public DoubleListNode(int val) {
            this.val = val;
        }
    }

    // 反转单链表 (使用头节点+新链表的方式)
    private static ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode newHead = new ListNode(-1); // 新链表的头节点
        newHead.next = null;

        // 不断地把原链表的节点摘下来头插到新链表上
        while (head != null) {
            ListNode temp = head.next; // 防止断链

            // 头插法
            head.next = newHead.next;
            newHead.next = head;

            head = temp;
        }

        return newHead.next;
    }

    // 反转双链表(采用原地反转的方式)
    private static DoubleListNode reverseDoubleList(DoubleListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        DoubleListNode preNode = null; // 当前正在处理节点的前驱节点
        while (head != null) {
            DoubleListNode temp = head.next; // 防止断链

            head.next = preNode;
            head.pre = temp;

            preNode = head;
            head = temp;
        }

        return preNode;
    }

}
```

## CD108/LC92. 反转部分单向链表

【题目链接】：

- NowCoder：[反转部分单向链表](https://www.nowcoder.com/practice/f11155006f154419b0bef6de8918aea2?tpId=101&tqId=33176&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- LeetCode：[92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

【题目描述】：

给定一个单链表，在链表中把第 L 个节点到第 R 个节点这一部分进行反转。

输入描述:

```
n 表示单链表的长度。

val 表示单链表各个节点的值。

L 表示翻转区间的左端点。

R 表示翻转区间的右端点。
```

输出描述:

```
在给定的函数中返回指定链表的头指针。
```

示例1

```
输入
5
1 2 3 4 5
1 3

输出
3 2 1 4 5
```

【解题思路】：

- 对于需要反转的部分，用头插法进行反转
- 对不需要反转的部分，不操作

具体做法：

首先新建 newHead 节点链接到原链表的 head 上，因为若 L = 1，需要 newHead 作为中介进行头插，相当于我们手动为这个链表加上了一个头节点。

核心思想：以 L-1 为头节点， L 为尾节点，将 L 后面的 R-L 个元素依次摘下头插到 L 前面

![](https://gitee.com/veal98/images/raw/master/img/20210409181531.png)

🚨 **注意最后需要将 R 这个节点链接到 L 后面那个节点，防止出现环**

最后返回 newHead.next 即可。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt(); // 单链表的长度
        ListNode head = new ListNode(sc.nextInt()); // 第一个元素节点
        ListNode p = head;
        for (int i = 1; i < n; i ++) {
            p.next = new ListNode(sc.nextInt());
            p = p.next;
        }

        int L = sc.nextInt(); // 左端点
        int R = sc.nextInt(); // 右端点

        ListNode head2 = reversePart(head, L, R);

        ListNode temp = head2;
        while (temp != null) {
            System.out.print(temp.val + " ");
            temp = temp.next;
        }

    }

    private static ListNode reversePart(ListNode head, int L, int R) {
        if (L >= R) {
            return head;
        }

        // 添加头节点，方便处理 L 是 head 的情况
        ListNode newHead = new ListNode(-1);
        newHead.next = head;


        // 找到 L 的前驱节点
        ListNode lPreNode = newHead;
        for (int i = 0; i < L-1; i ++) {
            lPreNode = lPreNode.next;
        }
        ListNode lNode = lPreNode.next; // 第 L 个节点

        // 从第 L+1 个节点开始头插
        ListNode p = lNode.next; // 第 L+1 个节点
        ListNode temp = p; // p 的后继节点，防止断链
        for (int i = 0; i < R-L; i ++) {
            temp = p.next; // 防止断链

            p.next = lPreNode.next;
            lPreNode.next = p;

            p = temp; // 继续下一个节点的处理
        }

        // 防止出现环
        lNode.next = temp;

        return newHead.next;
    }

    // 定义单链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }
}
```

## CD109. 环形链表的约瑟夫问题

【题目链接】：

- NowCoder：[CD109. 环形链表的约瑟夫问题](https://www.nowcoder.com/practice/c3b34059faf546d3a7ee28f2b0154286?tpId=101&tqId=33177&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

据说著名犹太历史学家 Josephus 有过以下故事：在罗马人占领乔塔帕特后，39 个犹太人与 Josephus 及他的朋友躲到一个洞中，39 个犹太人决定宁愿死也不要被敌人抓到，于是决定了一种自杀方式，41 个人排成一个圆圈，由第 1 个人开始报数，报数到 3 的人就自杀，然后再由下一个人重新报 1，报数到 3 的人再自杀，这样依次下去，直到剩下最后一个人时，那个人可以自由选择自己的命运。这就是著名的约瑟夫问题。现在请用单向环形链表得出最终存活的人的编号。

输入描述:

```
一行两个整数 n 和 m， n 表示环形链表的长度， m 表示每次报数到 m 就自杀。
```

输出描述:

```
输出最后存活下来的人编号(编号从1开始到n)
```

示例1

```
输入
5 2

输出
3
```

【解题思路】：

使用一个计数器（初始值赋为 1），然后直接循环遍历就好了。其中删除节点的时候需要前驱节点，单向循环链表里的最后一个节点就是天然的前驱节点（head 的前驱节点），直接用它就行：

- 如果链表为空或者链表节点数为 1，或者 m 的值小于 1，则不用调整就直接返回。
- 在环形链表中遍历每个节点，不断转圈，不断让每个节点报数（count ++）
- 当报数到达 m 时，就删除当前报数的节点。并将 count 归 1
- 不停地删除，直到环形链表中只剩一个节点，过程结束。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 环形链表长度
        int m = sc.nextInt(); // 报数

        // 构造环形链表
        ListNode head = new ListNode(1); // 第一个节点
        ListNode p = head; // 工作指针
        for (int i = 2; i <= n; i ++) {
            p.next = new ListNode(i);
            p = p.next;
        }
        p.next = head; // 成环

        System.out.println(josephusKill(head, m).val);
    }

    // 返回最后存活的节点
    private static ListNode josephusKill(ListNode head, int m) {
        if (head == null || head.next == head || m < 1) {
            return head;
        }

        // 找到链表的最后一个节点（天然的前驱节点）
        ListNode last = head;
        while (last.next != head) {
            last = last.next;
        }

        // 循环报数
        int count = 1;
        while (head != last) {
            // 删除当前节点
            if (count == m) {
                last.next = head.next;
                head = last.next;
                count = 1;
            }
            else {
                last = last.next;
                head = head.next;
                count ++;
            }
        }

        return head;
    }

    // 定义单链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }
}
```

【时间复杂度】：

每删除一个节点，都需要遍历 m 次，一共需要删除的节点数为 n-1，所以上述解法的时间复杂度为 O(n×m)

## CD113. 将单向链表按某值划分为左边小，中间相等，右边大的形式

【题目链接】：

- NowCoder：[CD113. 将单向链表按某值划分为左边小，中间相等，右边大的形式](https://www.nowcoder.com/practice/04fcabc5d76e428c8100dbd855761778?tpId=101&tqId=33181&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一个链表，再给定一个整数 pivot，请将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于 pivot 的节点， 右边部分都是大于 pivot 的节点。

除此之外，对调整后的节点顺序没有更多要求。

例如：链表 9->0->4->5->1，pivot=3。

调整后链表可以是 1->0->4->9->5，也可以是 0->1->9->5->4。总之，满足左部分都是小于 3的节点，中间部分都是等于 3 的节点（本例中这个部分为空），右部分都是大于 3 的节点即可。对某部分内部的节点顺序不做要求。

输入描述:

```
第一行两个整数 n 和 pivot，n 表示链表的长度。

第二行 n 个整数 ai 表示链表的节点。
```

输出描述:

```
请在给定的函数内返回链表的头指针。
```

示例1

```
输入
5 3
9 0 4 5 1

输出
1 0 4 5 9
```

【解题思路】：

思路其实也不难，就是将原链表中的所有节点依次划分进三个链表，三个链表分别为 small 代表左部分，equal代表中间部分，big 代表右部分。

例如，链表 7->9->1->8->5->2->5，pivot=5。在划分之后，small、equal、big 分别为：

- small：1->2->null
- equal：5->5->null 
- big：7->9->8->null

将 small、equal 和 big 三个链表重新串起来即可。整个过程需要特别注意对 null 节点的判断和处理。

【具体代码】：

```java
import java.util.List;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 链表长度
        int pivot = sc.nextInt();

        // 构造链表
        ListNode head = new ListNode(sc.nextInt()); // 第一个节点
        ListNode p = head; // 工作指针
        for (int i = 1; i < n; i ++) {
            p.next = new ListNode(sc.nextInt());
            p = p.next;
        }

        ListNode head2 = listPartition(head, pivot);
        ListNode cur = head2;
        while (cur != null) {
            System.out.print(cur.val + " ");
            cur = cur.next;
        }

    }

    private static ListNode listPartition(ListNode head, int pivot) {
        if (head == null) {
            return head;
        }

        ListNode sH = null; // 小的头
        ListNode sT = null; // 小的尾
        ListNode eH = null; // 相等的头
        ListNode eT = null; // 相等的尾
        ListNode bH = null; // 大的头
        ListNode bT = null; // 大的尾

        while (head != null) {
            ListNode temp = head.next; // 防止断链
            head.next = null; // 防止出现环

            // 放入小链表
            if (head.val < pivot) {
                if (sH == null) {
                    // 判断是否是第一个存入的元素
                    sH = head;
                    sT = head;
                }
                else {
                    sT.next = head;
                    sT = sT.next;
                }
            }
            // 放入相等的链表
            else if (head.val == pivot) {
                if (eH == null) {
                    eH = head;
                    eT = head;
                }
                else {
                    eT.next = head;
                    eT = eT.next;
                }
            }
            // 放入大链表
            else {
                if (bH == null) {
                    bH = head;
                    bT = head;
                }
                else {
                    bT.next = head;
                    bT = bT.next;
                }
            }

            head = temp;
        }


        // 小链表和相等的链表连接
        if (sT != null) {
            sT.next = eH;
            eT = (eT == null) ? sT : eT;
        }
        // 相等的链表和大链表连接
        if (eT != null) {
            eT.next = bH;
        }

        return (sH != null) ? sH : (eH != null) ? eH : bH;
    }


    // 定义单链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
        }
    }
}
```

注意这行代码，防止成环

![](https://gitee.com/veal98/images/raw/master/img/20210409223018.png)

## CD/LC138. 复制带随机指针的链表

【题目链接】：

- NowCoder：[LC138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)
- Nowcoder：书中有这个题目，但是牛客网上没有

【题目描述】：

给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。

例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。

返回复制链表的头节点。

用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：

- val：一个表示 Node.val 的整数。
- random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。

你的代码 只 接受原链表的头节点 head 作为传入参数。

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

示例 2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

示例 3：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```


示例 4：

```
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
```

【解题思路】：

方法一：先遍历一遍链表，使用哈希表保存原节点和副本节点的对应关系，然后再遍历一遍节点，处理一下 random 指针。

![](https://gitee.com/veal98/images/raw/master/img/20210411215037.png)

哈希表增删改查的操作时间复杂度都是 O(1)，普通方法一共只遍历链表两遍，所以上述解法的时间复杂度为 O(N)。因为使用了哈希表，所以额外空间复杂度为 O(N)。

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }
        // 使用哈希表保存原节点和副本节点的关系
        Map<Node, Node> map = new HashMap<>();
        Node cur = head;
        while (cur != null) {
            map.put(cur, new Node(cur.val));
            cur = cur.next;
        }
        
        // 再遍历一遍链表处理 random 指针
        cur = head;
        while (cur != null) {
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        
        return map.get(head);
    }
}
```

方法二：

![](https://gitee.com/veal98/images/raw/master/img/20210411220953.png)

```java
class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }
        
        // 创建副本节点并将其连接在对应的原节点后面
        Node cur = head;
        while (cur != null) {
            Node copy = new Node(cur.val);
            copy.next = cur.next;
            cur.next = copy;
            // 进入下一个节点的处理
            cur = copy.next;
        }
        
        // 再遍历一遍节点，处理 random 指针
        cur = head;
        while (cur != null) {
            Node copy = cur.next; // 副本节点
            copy.random = cur.random != null ? cur.random.next : null;
            // 进入下一个节点的处理
            cur = copy.next;
        }
        
        // 分离原节点和副本节点
        Node res = head.next;
        cur = head;
        while (cur != null) {
            Node temp = cur.next.next; // 下一个原节点
            Node copy = cur.next;
            cur.next = temp;
            copy.next = temp != null ? temp.next : null;
            
            cur = temp;
        }
        
        return res;
    }
}
```

## CD114/LC2. 两个链表生成相加链表

【题目链接】：

- NowCoder：[CD114. 两个链表生成相加链表](https://www.nowcoder.com/practice/2d4ae9ef94c8412ebe49118f8e1da2df?tpId=101&tqId=33182&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- LeetCode：[2. 两数相加 - Medium](https://leetcode-cn.com/problems/add-two-numbers/)

【题目描述】：

假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。

给定两个这种链表，请生成代表两个整数相加值的结果链表。

例如：链表 1 为 9->3->7，链表 2 为 6->3，最后生成新的结果链表为 1->0->0->0。

输入描述:

```
第一行两个整数 n 和 m，分别表示两个链表的长度。

第二行 n 个整数 ai 表示第一个链表的节点。

第三行 m 个整数 bi 表示第二个链表的节点。
```

输出描述:

```
输出一行整数表示结果链表。
```

示例1

```
输入
3 2
9 3 7
6 3

输出
1 0 0 0
```

【解题思路】：

- 将两个链表逆序，这样就可以依次得到从低位到高位的数字
- 同步遍历两个逆序后的链表，这样就依次得到两个链表从低位到高位的数字，然后逐一计算两个链表的两数之和，将其插入新链表，同时需要关注每一步是否有进位
- 当两个链表都遍历完成后，还要关注最后一次的进位信息是否为 1，如果为 1，还要生成一个节点
  值为 1 的新节点。（比如 9 + 1 = 10，两个一位数相加，但是结果是两位数，因为最后一次的进位是 1）
- 最后，逆序新链表，返回新链表的表头节点即可。

【具体代码】：

```java
import java.util.List;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 第一个链表的长度
        int m = sc.nextInt(); // 第二个链表的长度
        // 构造第一个链表
        ListNode head1 = new ListNode(sc.nextInt());
        ListNode cur = head1;
        for (int i = 1; i < n; i ++) {
            cur.next = new ListNode(sc.nextInt());
            cur = cur.next;
        }
        // 构造第二个链表
        ListNode head2 = new ListNode(sc.nextInt());
        cur = head2;
        for (int i = 1; i < m; i ++) {
            cur.next = new ListNode(sc.nextInt());
            cur = cur.next;
        }

        ListNode res = addList(head1, head2);
        cur = res;
        while (cur != null) {
        	System.out.println(cur.val + " ");
            cur = cur.next;
        }
    }

    // 两个链表相加
    private static ListNode addList(ListNode head1, ListNode head2) {
        if (head1 == null || head2 == null) {
            return (head1 == null) ? head2 : head1;
        }
        head1 = reverseList(head1);
        head2 = reverseList(head2);
        ListNode res = new ListNode(-1);
        ListNode p = res;

        ListNode cur1 = head1;
        ListNode cur2 = head2;
        int carry = 0; // 进位
        while (cur1 != null || cur2 != null) {
            int n1 = (cur1 == null) ? 0 : cur1.val;
            int n2 = (cur2 == null) ? 0 : cur2.val;
            int sum = n1 + n2 + carry;
            if (sum > 9) {
                p.next = new ListNode(sum - 10);
                p = p.next;
                carry = 1;
            }
            else {
                p.next = new ListNode(sum);
                p = p.next;
                carry = 0;
            }

            // 进入下一个节点的相加
            cur1 = (cur1 == null) ? null : cur1.next;
            cur2 = (cur2 == null) ? null : cur2.next;
        }

        // 注意最后一位进位的判断
        if (carry == 1) {
            p.next = new ListNode(1);
        }

        return reverseList(res.next);
    }

    // 原地反转单链表
    private static ListNode reverseList(ListNode head) {
        ListNode preNode = null; // 前驱节点
        while (head != null) {
            ListNode temp = head.next;

            head.next = preNode;
            preNode = head;

            // 进入下一个节点的判断
            head = temp;
        }
        return preNode;
    }

    // 定义单链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }
}
```

上述代码只能通过 80% 的案例，之前栈和队列章节 - CD188 题单调栈进阶那道题目也出现了这种情况。轻车熟路，考虑是 IO 次数太多导致的，用 StringBuilder 保存结果，然后一次性输出：

```java
ListNode res = addList(head1, head2);
cur = res;
StringBuilder sb = new StringBuilder();
while (cur != null) {
    sb.append(cur.val);
    sb.append(" ");
    cur = cur.next;
}
System.out.println(sb);
```

## CD/LC141. 判定链表是否有环

【题目链接】：

- LeetCode：[141. 环形链表 — Easy](https://leetcode-cn.com/problems/linked-list-cycle/)
- Nowcoder：书中有这个题目，但是牛客网上没有

【题目描述】：给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们<u>使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环</u>。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。

示例 1：

![](https://gitee.com/veal98/images/raw/master/img/20201113213046.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

【解题思路】：用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 `null`；<u>如果含有环，快指针最终会超慢指针一圈，和慢指针相遇</u>。

【具体代码】：

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
            
            // 快指针追上慢指针，存在环
            if(fast == slow)
                return true;
        }
        return false;
    }
}
```

## CD/LC142. 已知链表中含有环，返回入环的第一个节点

【题目链接】：

- LeetCode：[142. 环形链表 II — Medium](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
- Nowcoder：书中有这个题目，但是牛客网上没有

【题目描述】：给定一个链表，返回链表开始入环的第一个节点。 <u>如果链表无环，则返回 null</u>。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。

说明：不允许修改给定的链表。

示例 1：

![](https://gitee.com/veal98/images/raw/master/img/20201113213046.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

【解题思路】：我们使用两个指针，fast 与slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 \slow 指针在环中相遇。

如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nc

<img src="https://gitee.com/veal98/images/raw/master/img/20201113214440.png" style="zoom: 67%;" />

任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有

a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)

有了 a=c+(n-1)(b+c) 的等量关系，我们会发现：**从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离**。

因此，当发现slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，将 ptr 和 slow 同时每次向后移动一个位置。最终，它们会在入环点相遇。

【具体代码】：

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        ListNode ptr = head;
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
            
            // 快指针追上慢指针，存在环
            if(fast == slow){
                while(slow != ptr){
                    slow = slow.next;
                    ptr = ptr.next;
                }
                return ptr;
            }
                
        }
        return null;
    }
}
```

## CD/LC160. 两个无环链表的第一个公共节点

【题目链接】：

- LeetCode：[160. 相交链表 — Easy](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)
- Nowcoder：书中有这个题目，但是牛客网上没有

【题目描述】：

编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表：

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img" style="zoom:67%;" />

在节点 c1 开始相交。

示例 1：

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img" style="zoom:67%;" />

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

【解题思路】：

先走完长链表多出来的部分，然后再一同遍历两个链表，直到找到某个相同节点

【具体代码】：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }   
        
        // 计算两个链表的长度
        ListNode cur1 = headA;
        ListNode cur2 = headB;
        int len1 = 0;
        int len2 = 0;
        while (cur1 != null) {
            len1 ++;
            cur1 = cur1.next;
        }
        while (cur2 != null) {
            len2 ++;
            cur2 = cur2.next;
        }
        
        // 如果到最后一个节点了他俩仍然不是同一个节点，就说明这两个链表不相交
        if (cur1 != cur2) {
            return null;
        }
        
        ListNode longer = headA;
        ListNode shorter = headB;
        if (len1 < len2) {
            longer = headB;
            shorter = headA;
        }
        
        // 先走完长链表多出来的部分
        for (int i = 0; i < Math.abs(len1-len2); i ++) {
            longer = longer.next;
        }
        
        // 查找公众节点
        while (longer != null && shorter != null) {
            if (longer == shorter) {
                return longer;
            }
            longer = longer.next;
            shorter = shorter.next;
        }
        
        return null;
    }
}
```

## CD. 两个有环链表的第一个公共节点

【题目链接】：

- Nowcoder：书中有这个题目，但是牛客网上没有

【题目描述】：

这个题目其实是《程序员代码面试指南》一书中一个大题目拆分的一个小问题，原题描述是这样的：

在本题中，单链表可能有环，也可能无环。给定两个单链表的头节点 head1 和 head2，这两个链表可能相交，也可能不相交。请实现一个函数，如果两个链表相交，请返回相交的第一个节点；如果不相交，返回 null 即可。

要求：如果链表 1 的长度为 N，链表 2 的长度为 M，时间复杂度请达到 O(N+M)，额外空间复杂度请达到 O(1)。

显然，这个题目分两种情况：两个有环链表相交、两个无环链表相交（上题已完成），**一个有环一个无环是不可能相交的**。

【解题思路】：

假设链表 1 的第一个入环节点记为 loop1，链表 2 的第一个入环节点记为 loop2。

1）如果 loop1==loop2，那么两个链表的拓扑结构如图 2-8 所示。

![](https://gitee.com/veal98/images/raw/master/img/20210412215430.png)

这种情况下，我们只要考虑链表 1 从头开始到 loop1 这一段与链表 2 从头开始到 loop2 这一段，在那里第一次相交即可，而不用考虑进环该怎么处理，这就与寻找两个无环链表的第一个公共节点类似，只不过它是把 null 作为一个链表的终点，而现在这个问题是把 loop1(loop2)作为链表的终点。但是判断的主要过程是相同的。

2）如果 loop1!=loop2，两个链表不相交的拓扑结构如图 2-9 所示。两个链表相交的拓扑结构如图 2-10 所示。

![](https://gitee.com/veal98/images/raw/master/img/20210412215456.png)

如何分辨是这两种拓扑结构的哪一种呢？

让链表 1 从 loop1 出发，因为 loop1 和之后的所有节点都在环上，所以将来一定能回到 loop1：

- 如果回到 loop1 之前并没有遇到 loop2，说明两个链表的拓扑结构如图 2-9 所示，也就是不相交，直接返回 null；
- 如果回到 loop1 之前遇到了 loop2，说明两个链表的拓扑结构如图 2-10所示，也就是相交。因为 loop1 和 loop2 都在两条链表上，只不过 loop1 是离链表 1 较近的节点，loop2 是离链表 2 较近的节点。所以，此时返回 loop1 或 loop2 都可以。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    // 找到两个有环链表的第一个公共节点
    private static ListNode bothLoop(ListNode head1, ListNode head2) {
        // 找到两个有环链表的入环节点
        ListNode loop1 = detectCycle(head1);
        ListNode loop2 = detectCycle(head2);

        // 如果入环点是同一个
        if (loop1 == loop2) {
            // 判断到 loop1/loop2 之前这两个链表有没有相交
            ListNode cur1 = head1;
            ListNode cur2 = head2;

            int len1 = 0;
            int len2 = 0;
            while (cur1 != loop1) {
                len1 ++;
                cur1 = cur1.next;
            }
            while (cur2 != loop1) {
                len2 ++;
                cur2 = cur2.next;
            }

            if (cur1 != cur2) {
                return loop1;
            }

            ListNode longer = head1;
            ListNode shorter = head2;
            if (len1 < len2) {
                longer = head2;
                shorter = head1;
            }

            // 先走完较长的部分
            for (int i = 0; i < Math.abs(len1-len2); i ++) {
                longer = longer.next;
                shorter = shorter.next;
            }

            while (longer != loop1 && shorter != loop1) {
                if (longer == shorter) {
                    return longer;
                }
                longer = longer.next;
                shorter = shorter.next;
            }
        }
        // 如果不是同一个入环点
        else {
            ListNode cur = loop1.next;
            while (cur != loop1) {
                if (cur == loop2) {
                    return loop1;
                }
                cur = cur.next;
            }
            // 若 loop1 遇不上 loop2, 说明这两个有环链表不相交
            return null;
        }

        return null;
    }

    // 返回有环链表的入环节点
    private static ListNode detectCycle(ListNode head) {
        // 见 LC142
    }

    // 定义单链表结构
    private static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }
}
```

## CD119/LC20. 将单链表的每 K 个节点之间逆序

【题目链接】：

- NowCoder：[CD119. 将单链表的每K个节点之间逆序](https://www.nowcoder.com/practice/66285653d28b4ed6a15613477670e936?tpId=101&tqId=33187&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- LeetCode：[25. K 个一组翻转链表 — hard](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

【题目描述】：

给定一个单链表，实现一个调整单链表的函数，使得每 K 个节点之间的值逆序，如果最后不够 K 个节点一组，则不调整最后几个节点。

输入描述:

```
第一行一个整数 n，n 表示单链表的节点数量。

第二行 n 个整数 val 表示链表的各个节点的值。

第三行一个整数 K。
```

输出描述:

```
在给定的函数内返回链表的头指针。
```

示例1

```
输入
5
1 2 3 4 5
3

输出
3 2 1 4 5
```

<img src="https://gitee.com/veal98/images/raw/master/img/20210317174628.png" style="zoom:67%;" />

【解题思路】：

1）解法一：利用栈

![](https://gitee.com/veal98/images/raw/master/img/20210412225131.png)

可以这么理解：我们用两个变量保存要被逆序的这段 K 个节点的前驱节点和后继节点，而这 K 个节点存在栈中，我们将这 K 个节点依次出栈插入到前驱节点和后继节点之间就行了。

```java
import java.util.Scanner;
import java.util.Stack;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 链表长度

        // 构造链表
        ListNode head = new ListNode(sc.nextInt()); // 第一个节点
        ListNode p = head; // 工作指针
        for (int i = 1; i < n; i ++) {
            p.next = new ListNode(sc.nextInt());
            p = p.next;
        }

        int K = sc.nextInt(); // 整数 K

        ListNode res = reverseKNodes1(head, K);
        ListNode cur = res;
        while (cur != null) {
            System.out.print(cur.val + " ");
            cur = cur.next;
        }
    }

    // 每 K 个节点一组逆序链表
    private static ListNode reverseKNodes1(ListNode head, int K) {
        if (K <= 1) {
            return head;
        }

        Stack<ListNode> stack = new Stack<>();
        ListNode cur = head;
        ListNode newHead = head;
        ListNode pre = null;
        ListNode next = null;
        while (cur != null) {
            next = cur.next;
            stack.push(cur);
            if (stack.size() == K) {
                // 左开右开，不包含 pre 和 next 节点
                // pre 是本次逆序的 K 个节点的前驱节点
                // next 是本次逆序的 K 个节点的后继节点
                pre = resign1(stack, pre, next);
                // 第一组逆序完需要更新下头节点，后面组保持第一组已经更新好的头节点的值就行了
                // 第一组逆序完 newHead 仍然等于 head
                newHead = (newHead == head) ? cur : newHead;
            }
            // 进入下一个节点的判断
            cur = next;
        }
        return newHead;
    }

    // 逆序链表 (left,right) 之间的节点 (左开右开)
    // 栈中存储的自底向上就是 (left,right) 之间的节点 (不包含left 和 right)
    private static ListNode resign1(Stack<ListNode> stack, ListNode left, ListNode right) {
        ListNode cur = stack.pop();
        if (left != null) {
            left.next = cur;
        }

        while (!stack.isEmpty()) {
            cur.next = stack.pop();
            cur = cur.next;
        }

        cur.next = right;

        // 返回逆序的这 K 个节点的最后一个节点，这样方便用来作下一段 K 个节点的前驱节点
        return cur;

    }


    // 定义单链表结构
    private static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

}
```

2）解法二：

不用栈，直接在原链表上进行逆序，不过思路是一样的，用两个变量保存要被逆序的这段 K 个节点的前驱节点和后继节点，然后逆序这两个节点之间的 K 个节点就行了。

```java
	private static ListNode reverseKNodes2(ListNode head, int K) {
        if (K <= 1) {
            return head;
        }

        ListNode cur = head;
        ListNode pre = null;
        ListNode start = null;
        ListNode end = null;
        ListNode next = null;
        int count = 1;
        while (cur != null) {
            next = cur.next;
            if (count == K) {
                start = (pre == null) ? head : pre.next;
                // 第一组逆序完需要更新下头节点，后面组保持第一组已经更新好的头节点的值就行了
                // 第一组逆序完 pre 仍然是 null
                head = (pre == null) ? cur : head;
                pre = resign2(pre, start, cur, next);
                count = 0;
            }
            count ++;
            // 进入下一个节点的判断
            cur = next;
        }
        return head;
    }

    // 逆序 [start, end] 之间的节点，left 是这段节点的前驱节点，right 是这段节点的后继节点
    private static ListNode resign2(ListNode left, ListNode start, ListNode end, ListNode right) {
        ListNode cur = start.next; // 第一个进行头插的节点
        // 这里没办法用头插法（因为第一个前驱节点是 null），采用原地反转的方式
        ListNode pre = start;
        while (cur != right) {
            ListNode next = cur.next; // 防止断链

            cur.next = pre;
            pre = cur;

            // 进入下一个节点的头插
            cur = next;
        }
        if (left != null) {
            left.next = end;
        }
        start.next = right;

        // 返回逆序的这 K 个节点的最后一个节点，这样方便用来作下一段 K 个节点的前驱节点
        return start;
    }
```

## CD137. 删除无序链表中值重复出现的节点

【题目链接】：

- NowCoder：[CD137. 删除无序链表中值重复出现的节点](https://www.nowcoder.com/practice/fb3105d036344c6a8ecbef996e0b23a0?tpId=101&tqId=33205&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一个无序链表，删除其中值重复出现的节点(保留当中顺序遍历第一个出现的节点)。

输入描述:

```
第一行一个整数 n，表示单链表的节点数量。
第二行 n 个整数表示单链表的节点的值。
```

输出描述:

```
顺序输出单链表每个节点的值。
```

示例1

```
输入
5
1 3 2 3 1

输出
1 3 2
```

【解题思路】：

1）解法一：直接暴力解，时间复杂度 O(N^2)，没法 AC。对于每个节点（比如值为 1），往后检查所有节点，并删除值为 1 的节点。

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 链表长度

        // 构造链表
        ListNode head = new ListNode(sc.nextInt()); // 第一个节点
        ListNode p = head; // 工作指针
        for (int i = 1; i < n; i ++) {
            p.next = new ListNode(sc.nextInt());
            p = p.next;
        }

        ListNode res = removeRepeatElements(head);
        ListNode cur = res;
        while (cur != null) {
            System.out.print(cur.val + " ");
            cur = cur.next;
        }
    }

    // 暴力解法
    private static ListNode removeRepeatElements1(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode cur = head;
        while (cur != null) {
            ListNode pre = cur; // 前驱节点
            ListNode temp = cur.next; // 待判断节点（是否需要被删除）
            while (temp != null) {
                ListNode next = temp.next; // 防止断链

                if (temp.val == cur.val) {
                    pre.next = temp.next;
                }
                else {
                    pre = temp;
                }
                // 进入下一个节点的判断
                temp = next;
            }
            // 进入下一个节点的判断
            cur = cur.next;
        }

        return head;
    }

    // 定义单链表结构
    private static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

}
```

2）解法二：使用 HashSet，因为头节点是不用删除的节点，所以首先将头节点的值放入哈希表。

从头节点的下一个节点开始往后遍历节点，假设当前遍历到 cur 节点，先检查 cur 的值是否在哈希表中，如果在，则说明 cur 节点的值是之前出现过的，就将 cur 节点删除；如果不在，将 cur 节点的值加入哈希表。

只需一次遍历即可，时间复杂度 O(N)

```java
	private static ListNode removeRepeatElements2(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        Set<Integer> set = new HashSet<>();

        set.add(head.val); // 头节点肯定不会被删除

        ListNode cur = head.next;
        ListNode pre = cur; // 前驱节点
        while (cur != null) {
            ListNode next = cur.next; // 防止断链

            // 若 set 中已存在该值，则删除该节点
            if (set.contains(cur.val)) {
                pre.next = cur.next;
            }
            else {
                set.add(cur.val);
                pre = cur;
            }

            // 进入下一个节点的判断
            cur = next;
        }

        return head;
    }
```

## LC83. 删除排序链表中的重复元素

【题目链接】：

- [83. 删除排序链表中的重复元素 — Easy](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

【题目描述】：

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

示例 1:

```
输入: 1->1->2
输出: 1->2
```


示例 2:

```
输入: 1->1->2->3->3
输出: 1->2->3
```

【解题思路】：

1）方法一：<u>CD137. 删除无序链表中值重复出现的节点</u> 使用的两个方法完全适用于这个题目。只是效率不高，针对有序的链表我们可以有更优的手段。

2）方法二：当 cur.val 和 cur.next.val 相等时说明需要去重，则将 cur 的下一个指针指向下一个的下一个，这样就能达到去重复的效果；如果不相等则 cur 移动到下一个位置继续循环

时间复杂度 O(N)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        
        if (head == null || head.next == null) {
            return head;
        }
        
        ListNode cur = head;
        while (cur != null && cur.next != null) {
            if (cur.val == cur.next.val) {
                cur.next = cur.next.next;
            }
            else {
                cur = cur.next;
            }
        }
        
        return head;
    }
}
```

3）方法三：

使用两个指针，一个指针 `slow` 指向某段重复元素的第一个元素，另一个指针用来扫描重复元素。

找到一个不重复的元素就告诉 `slow` 并让 `slow` 连接到 `fast`，并让 `slow` 向前一步。这样当 `fast` 指针遍历完整个数组 `nums` 后，`[0..slow]` 就是不重复元素。

时间复杂度 O(N)

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) {
            return null;
        }
        
        ListNode slow = head; // 第一个节点肯定不会被删除
        ListNode fast = head; // 用来扫描重复节点
        
        while (fast != null) {
            if (fast.val != slow.val) {
                slow.next = fast;
                slow = slow.next;
            }
            fast = fast.next;
        }
        // 断开与后面重复元素的连接
        slow.next = null;
        return head;
    }
}
```

## LC82. 删除排序链表中的重复元素 II

【题目链接】：

- LeetCode：[82. 删除排序链表中的重复元素 II — Medium](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

【题目描述】：

给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。

示例 1:

```
输入: 1->2->3->3->4->4->5
输出: 1->2->5
```


示例 2:

```
输入: 1->1->1->2->3
输出: 2->3
```

【解题思路】：

和上题思路差不多，使用两个指针，一个指针指向某段重复元素的前驱节点，另一个指针用来扫描重复元素。不过这里第一个元素节点也有被删除的可能性，所有引入一个头节点，方便第一个元素节点处理。

【具体代码】：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        
        if (head == null) {
            return null;
        }
        
        // 创建头节点
        ListNode newHead = new ListNode();
        newHead.next = head;
        
        ListNode pre = newHead; // 重复节点的前驱节点
        ListNode cur = head; // 扫描重复节点
        
        while (cur != null) {
            // 遇到重复出现的结点
            if (cur.next != null && cur.val == cur.next.val) {
                // 循环遍历到该结点重复出现的末尾
                while (cur.next != null && cur.val == cur.next.val) {
                    cur = cur.next;
                }
                // 删除这些重复节点
                pre.next = cur.next;
                
            }
            // 没遇到重复出现的结点,移动 pre
            else {
                pre = cur;
            }
            // 不管遇没遇到重复结点，cur都是一直向前的
            cur = cur.next;  
        }
        
        return newHead.next;
    }
}
```

## CD138. 在链表中删除指定值的节点

【题目链接】：

- LeetCode：[CD138. 在链表中删除指定值的节点](https://www.nowcoder.com/practice/1a5fd679e31f4145a10d46bb8fd3d211?tpId=101&tqId=33206&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给出一个链表和一个整数 num，输出删除链表中节点值等于 num 的节点之后的链表。

输入描述：

```
第一行一个整数 n，n 表示单链表的节点数量。

第二行 n 个整数表示单链表的各个节点的值。

第三行一个整数 num。
```

输出描述：

```
在给定的函数中返回指定链表的头指针。
```

示例 1

```
输入
4 
1 2 3 4
3

输出
1 2 4
```

【解题思路】：

这个没啥好说的，不过这个题目没说链表元素是否有重复的，所以这里就当有重复元素来做了

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        ListNode head = new ListNode(sc.nextInt());
        ListNode cur = head;
        for (int i = 1; i < n; i ++) {
            cur.next = new ListNode(sc.nextInt());
            cur = cur.next;
        }
        int num = sc.nextInt();

        ListNode res = removeValue(head, num);
        cur = res;
        while (cur != null) {
            System.out.print(cur.val + " ");
            cur = cur.next;
        }
    }

    // 删除 num
    private static ListNode removeValue(ListNode head, int num) {
        ListNode newHead = new ListNode(-1);
        newHead.next = head;

        ListNode pre = newHead;
        ListNode cur = head;
        while (cur != null) {
            ListNode next = cur.next; // 防止断链
            if (cur.val == num) {
                pre.next = cur.next;
            }
            else {
                pre = cur;
            }
            cur = next;
        }

        return newHead.next;
    }

    // 定义单链表结构
    private static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }
}
```

## CD156. 将搜索二叉树转换成双向链表

【题目链接】：

- NowCoder：[CD156. 将搜索二叉树转换成双向链表](https://www.nowcoder.com/practice/2d3188a7e3ce4af2a9ebd5b89843fced?tpId=101&tqId=33224&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

对二叉树的节点来说，有本身的值域，有指向左孩子节点和右孩子节点的两个指针；对双向链表的节点来说，有本身的值域，有指向上一个节点和下一个节点的指针。在结构上，两种结构有相似性，现在有一棵搜索二叉树，请将其转换成一个有序的双向链表。

输入描述:

```
第一行一个数字 n 表示二叉树的总结点数。
以下 n 行每行三个整数 fa lch rch，表示节点 fa 的左儿子节点为 lch，右儿子节点为 rch。(若 lch 为 0 则表示 fa 没有左儿子，rch同理)

第一行的 fa 为根节点。

ps:节点的标号就是节点的值。
```

输出描述:

```
在给定的函数中返回双向链表的头指针。
```

示例1

```
输入
9
6 4 7
4 2 5
2 1 3
5 0 0
1 0 0
3 0 0
7 0 9
9 8 0
8 0 0 

输出
1 2 3 4 5 6 7 8 9 
```

【解题思路】：

题目本身思路没啥难度，中序遍历二叉树然后转换成链表即可。难点我觉得在构造二叉树上面

【具体代码】：

```java
import java.util.*;
import java.util.concurrent.TransferQueue;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        // 构建二叉树
        TreeNode root = createTree(sc);
        // 将二叉树转为双向链表
        ListNode res = convert(root);
        ListNode cur = res;
        while (cur != null) {
            System.out.print(cur.val + " ");
            cur = cur.next;
        }
    }

    // 搜索二叉树转为双向链表
    private static ListNode convert(TreeNode root) {
        // 存储中序遍历的结果
        Queue<Integer> queue = new LinkedList<>();
        inOrderTree(root, queue);
        if (queue.isEmpty()) {
            return null;
        }
        ListNode head = new ListNode(queue.poll());
        ListNode preNode = head;
        while (!queue.isEmpty()) {
            ListNode cur = new ListNode(queue.poll());
            preNode.next = cur;
            cur.pre = preNode;

            preNode = cur;
        }

        return head;


    }

    // 中序遍历
    private static void inOrderTree(TreeNode root, Queue queue) {
        if (root == null) {
            return;
        }
        inOrderTree(root.left, queue);
        queue.add(root.val);
        inOrderTree(root.right, queue);

    }

    // 构建二叉树
    public static TreeNode createTree(Scanner sc) {
        String[] values = sc.nextLine().split(" ");
        if (values.length < 3) {
            return null;
        }
        int value = Integer.parseInt(values[0]);
        int left = Integer.parseInt(values[1]);
        int right = Integer.parseInt(values[2]);

        TreeNode root = new TreeNode(value);
        if(left != 0){
            root.left = createTree(sc);
        }
        if(right != 0){
            root.right = createTree(sc);
        }
        return root;

    }

    // 定义单链表结构
    private static class ListNode {
        private int val;
        private ListNode next;
        private ListNode pre;

        public ListNode(int val) {
            this.val = val;
            this.pre = null;
            this.next = null;
        }
    }

    // 定义二叉树结构
    private static class TreeNode {
        private TreeNode left;
        private TreeNode right;
        private int val;

        public TreeNode(int val) {
            this.val = val;
            left = null;
            right = null;
        }
    }
}
```

坑爹题，代码一点毛病没有，运行的结果一直不正确，直接提交竟然过了，然后跑的别人运行成功的代码结果也都是错误的，我懵逼了，浪费了好长时间。

## CD139. 单链表的选择排序

【题目链接】：

- NowCoder：[CD139. 单链表的选择排序](https://www.nowcoder.com/practice/78f83c3f12d2464591ebc5a73183db35?tpId=101&tqId=33207&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一个无序单链表，实现单链表的选择排序(按升序排序)。要求：额外空间复杂度为 O(1)。

输入描述:

```
第一行一个整数 n，表示单链表的节点数量。
第二行 n 个整数 val 表示单链表的各个节点。
```

输出描述:

```
在给出的函数内返回给定链表的头指针。
```

示例1

```
输入
5
1 3 2 4 5

输出
1 2 3 4 5
```

【解题思路】：

既然要求额外空间复杂度为 O(1)，就不能把链表装进数组等容器中进行排序，排好序之后再重新连接，而是要求在原链表上利用有限几个变量完成选择排序的过程。选择排序是从未排序的部分中找到最小值，然后放在排好序部分的尾部，逐渐将未排序的部分缩小，最后全部变成排好序的部分。

- 开始时默认整个链表都是未排序的部分，我们引入头节点方便处理
- 每次在未排序的部分中找到最小值的节点，然后把这个节点从未排序的链表中删除，删除的过程当然要保证未排序部分的链表在结构上不至于断开。例如，2->1->3，删除节点 1 之后，链表应该变成 2->3，**这就要求我们应该找到要删除节点的前一个节点**。
- 把删除的节点（也就是每次的最小值节点）连接到排好序部分的链表尾部。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        ListNode head = new ListNode(sc.nextInt());
        ListNode cur = head;
        for (int i = 1; i < n; i ++) {
            cur.next = new ListNode(sc.nextInt());
            cur = cur.next;
        }

        ListNode res = selectionSort(head);
        cur = res;
        while (cur != null) {
            System.out.print(cur.val + " ");
            cur = cur.next;
        }
    }

    private static ListNode selectionSort(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode newHead = new ListNode(-1);
        newHead.next = head;

        ListNode tail = newHead; // 已排序部分的尾部
        ListNode cur = head; // 未排序部分的头部
        while (cur != null) {
            // 在未排序部分中找到最小节点的前驱节点
            ListNode smallPre = getSmallestPreNode(cur);
            // 如果 smallPre == null，说明 small 就是 cur
            ListNode small = cur;
            // 如果 smallPre != null, 则从未排序部分中删除该最小节点
            if (smallPre != null) {
                small = smallPre.next;
                smallPre.next = small.next;
            }

            // 如果 small 就是 cur，则进入下一个节点的判断
            if (small == cur) {
                cur = cur.next;
            }

            // 在已排序部分的尾部添加上 small
            tail.next = small;
            // 更新已排序部分的尾部
            tail = tail.next;
        }

        return newHead.next;
    }

    // 获取链表上最小节点的前驱节点
    private static ListNode getSmallestPreNode(ListNode head) {
        ListNode smallPre = null; // 最小节点的前驱节点
        ListNode small = head; // 最小节点
        ListNode pre = head;
        ListNode cur = head;
        while (cur != null) {
            if (cur.val < small.val) {
                smallPre = pre;
                small = cur;
            }
            pre = cur;
            cur = cur.next;
        }
        return smallPre;
    }

    // 定义单链表结构
    private static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

}
```

和选择排序一样，如果链表的长度为 N，时间复杂度为 O(N^2)，额外空间复杂度为 O(1)。

## CD157/LC237. 删除链表中给定的节点

【题目链接】：

- NowCoder：[CD157. 一种怪异的节点删除方式](https://www.nowcoder.com/practice/86896a89874d4676a3c8d712d9a1eef4?tpId=101&tqId=33225&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- LeetCode：[LC237. 删除链表中给定的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

【题目描述】：

链表节点值类型为 int 类型，给定一个链表中的节点 node，但不给定整个链表的头节点。如何在链表中删除 node ? 请实现这个函数。

输入描述:

```
给出一个单链表的节点。
```

输出描述:

```
不需要返回值。
```

示例1

```
输入
5 
1 2 4 6 7
3 # 这个表示的是要删除第 3 个节点，而不是值为 3 的节点

输出
1 2 6 7
```

【解题思路】：

这道题只能访问到被删除的节点，而无法访问到被删除节点的前驱节点。因此，不能通过其前驱节点和后继节点来删除当前节点。

可以用被删除节点的后继节点（假设为节点 a）的节点值覆盖要被删除节点的节点值，然后将节点 a 删除。

两行代码搞定。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        ListNode head = new ListNode(sc.nextInt());
        ListNode cur = head;
        for (int i = 1; i < n; i ++) {
            cur.next = new ListNode(sc.nextInt());
            cur = cur.next;
        }
        
        int index = sc.nextInt();
        ListNode node = head;
        for (int i = 1; i < index; i ++) {
            node = node.next;
        }

        deleteNode(node);
        cur = head;
        while (cur != null) {
            System.out.print(cur.val + " ");
            cur = cur.next;
        }
    }

    private static void deleteNode(ListNode node) {
        if (node == null) {
            return ;
        }
        // 将 node 的值覆盖为其后继节点的值
        node.val = node.next.val;

        // 删除 node.next
        node.next = node.next.next;
    }

    // 定义单链表结构
    private static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }
}
```

【存在的问题】：

这样做虽然很方便，但其实是存在很多问题的：

1）问题一：这样的删除方式**无法删除最后一个节点**。还是以原示例来说明，如果知道要删除节点 3，而不知道头节点。但它是最后的节点，根本没有下一个节点来代替节点 3 被删除，那么只有让节点 2 的 next 指向 null 这一种办法，而我们又根本找不到节点 2，所以根本没法正确删除节点 3。

2）问题二：这种删除方式在本质上根本就不是删除了 node 节点，而是把 node 节点的值改变，然后删除 node 的下一个节点，**在实际的工程中可能会带来很大问题**。

比如，工程上的一个节点可能代表很复杂的结构，节点值的复制会相当复杂，或者可能改变节点值这个操作都是被禁止的；再如，工程上的一个节点代表提供服务的一个服务器，外界对每个节点都有很多依赖，比如，示例中删除节点 2 时，其实影响了节点 3 对外提供的服务。

## CD158. 向有序的环形单链表中插入新节点

【题目链接】：

- NowCoder：[CD158. 向有序的环形单链表中插入新节点](https://www.nowcoder.com/practice/8a2ed8d048f241fd92b478140bad18a1?tpId=101&tqId=33226&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

一个环形单链表从头节点 head 开始不降序，同时由最后的节点指回头节点。给定这样一个环形单链表的头节点 head 和 一个整数 num， 请生成节点值为 num 的新节点，并插入到这个环形链表中，保证调整后的链表依然有序。

输入描述:

```
环形单链表的头节点 head 和 一个整数 num。
```

输出描述:

```
在给定的函数内返回新的环形单链表的头指针。
```

示例1

```
输入
5
1 2 3 4 5
6

输出
1 2 3 4 5 6
```

【解题思路】：

直接给出时间复杂度为 O(N)、额外空间复杂度为 O(1)的方法。具体过程如下：

- 生成节点值为 num 的新节点，记为 newNode。
- 如果链表为空，让 newNode 自己组成环形链表，然后直接返回 node。
- 如果链表不为空，令变量 pre = head，cur = head.next，然后令 pre 和 cur 同步移动下去，如果遇到 pre 的节点值小于或等于 num，并且 cur 的节点值大于或等于 num，说明 newNode 应该在 pre 节点和 cur 节点之间插入，插入 newNode，然后返回 head 即可。
- 如果 pre 和 cur 转了一圈，这期间都没有发现步骤 3 所说的情况，说明 newNode 应该插入到头节点的前面，这种情况之所以会发生，要么是因为 node 节点的值比链表中每个节点的值都大，要么是因为 node 的值比链表中每个节点的值都小。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        ListNode head = new ListNode(sc.nextInt());
        ListNode cur = head;
        for (int i = 1; i < n; i ++) {
            cur.next = new ListNode(sc.nextInt());
            cur = cur.next;
        }
        cur.next = head; // 成环

        int insertVal = sc.nextInt();
        ListNode res = insertNum(head, insertVal);
        // 输出环形链表
        cur = res;
        System.out.print(cur.val + " ");
        cur = cur.next;
        while (cur != res) {
            System.out.print(cur.val + " ");
            cur = cur.next;
        }
    }

    private static ListNode insertNum(ListNode head, int num) {
        ListNode insertNode = new ListNode(num);
        if (head == null) {
            insertNode.next = insertNode;
            return insertNode;
        }
        ListNode pre = head;
        ListNode cur = head.next;
        while (cur != head) {
            if (cur.val >= num && pre.val <= num) {
                // 插入新节点
                break;
            }
            pre = cur;
            cur = cur.next;
        }
        // 如果循环遍历了一圈，仍然没有找到合适的位置插入，说明这个值比所有的值都要大或者小，将其插入在 head 之前就行了
        insertNode.next = cur;
        pre.next = insertNode;

        // 如果 insertNode 节点的值比链表中每个节点的值都小，应该把 insertNode 作为链表新的头节点返回
        return head.val < num ? head : insertNode;
    }

    // 定义单链表结构
    private static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }
}
```

## CD159/LC21. 合并两个有序的单链表

【题目链接】：

- NowCoder：[CD159. 合并两个有序的单链表](https://www.nowcoder.com/practice/98a51a92836e4861be1803aaa9037440?tpId=101&tqId=33227&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- LeetCode：[21. 合并两个有序链表 - Easy](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

【题目描述】：

给定两个升序的单链表的头节点 head1 和 head2，请合并两个升序链表， 合并后的链表依然升序，并返回合并后链表的头节点。

输入描述:

```
两个升序的单链表的头节点 head1 和 head2
```

输出描述:

```
在给定的函数内返回新链表的头指针。
```

示例1

```
输入
5
1 2 3 4 5
6 
7 8 9 10 11 12

输出
1 2 3 4 5 7 8 9 10 11 12
```

【解题思路】：

Easy 题，直接归并就好了。两两比较，每次选择较小的元素加入新链表

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        // 构建第一个链表
        int n1 = sc.nextInt();
        ListNode head1 = new ListNode(sc.nextInt());
        ListNode cur = head1;
        for (int i = 1; i < n1; i ++) {
            cur.next = new ListNode(sc.nextInt());
            cur = cur.next;
        }
        // 构建第二个链表
        int n2 = sc.nextInt();
        ListNode head2 = new ListNode(sc.nextInt());
        cur = head2;
        for (int i = 1; i < n2; i ++) {
            cur.next = new ListNode(sc.nextInt());
            cur = cur.next;
        }

        ListNode res = merge(head1, head2);
        cur = res;
        StringBuilder sb = new StringBuilder();
        while (cur != null) {
            sb.append(cur.val);
            sb.append(" ");
            cur = cur.next;
        }
        System.out.println(sb);
    }

    private static ListNode merge(ListNode head1, ListNode head2) {
        ListNode p1 = head1;
        ListNode p2 = head2;
        ListNode res = new ListNode(-1);
        ListNode p3 = res;
        while (p1 != null && p2 != null) {
            if (p1.val < p2.val) {
                p3.next = p1;
                p1 = p1.next;
            }
            else {
                p3.next = p2;
                p2 = p2.next;
            }
            p3 = p3.next;
        }
        // 处理较长的链表
        if (p1 != null) {
            p3.next = p1;
        }
        if (p2 != null) {
            p3.next = p2;
        }

        return res.next;
    }

    static class ListNode {
        private int val;
        private ListNode next;
        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }
}
```

## CD160. 按照左右半区的方式重新组合单链表

【题目链接】：

- NowCoder：[CD160. 按照左右半区的方式重新组合单链表](https://www.nowcoder.com/practice/a7a348bdb4634e228cf7704c8a2a8bda?tpId=101&tqId=33228&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一个单链表的头部节点 head，链表长度为 N，如果 N 是偶数，那么前 N / 2 个节点算作左半区，后 N / 2 个节点算作右半区；如果 N 为奇数，那么前 N / 2 个节点算作左半区，后 N / 2 + 1个节点算作右半区。左半区从左到右依次记为 L1->L2->...，右半区从左到右依次记为 R1->R2->...，请将单链表调整成 L1->R1->L2->R2->... 的形式。

输入描述:

```
单链表的头节点 head。
```

输出描述:

```
在给定的函数内返回链表的头指针。
```

示例1

```
输入
6
1 2 3 4 5 6

输出
1 4 2 5 3 6
```

【解题思路】：

整体思路还是比较明了了，就是分开左右两边的链表，然后把右半部分的链表依次插入到左边部分的链表。

这里面需要注意的一点就是对于中点的划分，比如 1 2 3 它的左部分链表是 1，右部分链表是 2 3，也就是说奇数的时候中点是 N/2，这里需要稍微做一些文章。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        ListNode head = new ListNode(sc.nextInt());
        ListNode cur = head;
        for (int i = 1; i < n; i ++) {
            cur.next = new ListNode(sc.nextInt());
            cur = cur.next;
        }

        ListNode res = relocate(head);
        cur = res;
        while (cur != null) {
            System.out.print(cur.val + " ");
            cur = cur.next;
        }

    }

    private static ListNode relocate(ListNode head) {
        if (head == null || head.next == null || head.next.next == null) {
            return head;
        }

        ListNode slow = head;
        ListNode fast = head.next; // 获得左半部分得最后一个节点(这里需要注意，在奇数时我们要找的是第 N/2 个)
        // 找到链表的中点
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            // 下面这个判断很重要，这样才能符合题意的获得左半部分得最后一个节点
            if (fast != null ) {
                slow = slow.next;
            }
        }
        // 分开左右部分链表
        ListNode right = slow.next; // 右半部分链表的第一个节点
        slow.next = null;

        // 合并左右部分链表
        return mergeLR(head, right);
    }

    private static ListNode mergeLR(ListNode left, ListNode right) {
        ListNode cur = left;

        while (cur.next != null) {
            ListNode next = right.next; // 防止断链

            right.next = cur.next;
            cur.next = right;

            right = next;
            cur = cur.next.next;
        }
        // right 可能会多一个
        cur.next = right;

        return left;
    }

    static class ListNode {
        private int val;
        private ListNode next;
        public ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }
}
```

