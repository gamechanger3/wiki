# 递归和动态规划

## 动态规划解题步骤

> 参考帅地大佬的这篇文章 [告别动态规划，连刷 40 道动规算法题，我总结了动规的套路](https://mp.weixin.qq.com/s/pg-IJ8rA1duIzt5hW1Cycw)

**动态规划算法与分治法类似，其基本思想都是将待求解问题分解成若干个子问题，先求解子问题，再结合这些子问题的解得到原问题的解。**（通过子问题的解得到原问题的解，满足**最优子结构**性质）

与分治法不同的是，**适合用动态规划法求解的问题经分解得到的子问题往往不是互相独立的，存在「重叠子问题」**，如果用分治法的话效率会极其低下，所以需要记录所有已解决的子问题的答案，避免不必要的计算。

总结来说，**动态规划算法的总体思想就是保存已解决的子问题的答案（一般是用一维数组或者二维数组来保存），在需要时使用，从而避免大量重复计算**

下面我们先来讲下做动态规划题很重要的三个步骤，

- 第一步：定义**辅助数组的含义**，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧，那么这个 dp[i] 是代表什么意思？一般来说，dp[i] 代表的东西就是题目要求的东西。
- 第二步：找出**数组元素之间的关系式**，也就是**状态转移方程**。我觉得动态规划，还是有一点类似于我们高中学习时的归纳法的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]…..dp[1]，来推出 dp[n] 的，也就是说可以利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]
- 第三步：找出**初始值（base case）**。学过数学归纳法的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，这就是所谓的初始值。

按上面的套路走，最后的结果就可以套这个框架：

```java
// 初始化 base case
dp[0][0][...] = base
// 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

🚨🚨🚨 注意，**一定要注意循环的顺序问题**，下面这几张图画的简直不要太清晰，来源于 [LeetCode liweiwei1419](https://leetcode-cn.com/u/liweiwei1419/)：（这是大佬针对某个题目的讲解，大家忽略图中标注的的错误和正确，只需要看填表顺序和对应的 for 循环就可以了）

![image.png](https://pic.leetcode-cn.com/4a24bbe4e55421f4f7d199b14e961eff792146092dd9a0c18cf06c824728407c-image.png)

![](https://pic.leetcode-cn.com/7e9d1f1dbe2095b0609233faa03b224ab32adf832515de1ce15b496f2cbdf0ab-image.png)

以下面的【CD186. 矩阵的最小路径和】为例，我们来看看一道动态规划问题该如何解。

## CD186. 矩阵的最小路径和

【题目链接】：

- NowCoder：[CD186. 矩阵的最小路径和](https://www.nowcoder.com/practice/2fb62a4500af4f4ba5686c891eaad4a9?tpId=101&&tqId=33254&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)

【题目描述】：

给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。

示例1

输入：

```
4 4
1 3 5 9
8 1 3 4
5 0 6 1
8 8 4 0
```

输出：

```
12
```

【解题思路】：动态规划。

**辅助数组**：`dp[i][j]` 表示从坐标 (0, 0) 到坐标 (i, j) 的最小路径和

**状态转移方程**：

![](https://gitee.com/veal98/images/raw/master/img/20210526170327.png)

`dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + m[i][j]`

<img src="https://gitee.com/veal98/images/raw/master/img/20210526173429.png" style="zoom:67%;" />

在计算 `dp[i][j]` 之前，需要获取 `dp[i-1][j] 和 dp[i][j-1]` 的值，由上图可知，i，j 直接从头开始顺序遍历即可。

**base case**：第一行的数字只能由 (0,0) 往右走得到，所以 (0,0) 位置到 (0, j) 位置的路径和就是 `m[0][0..j]` 这些值的累加结果。

第一列的数字只能由 (0,0) 往下走得到，所以(0,0)位置到(i,0)位置的路径和就是 `m[0..i][0]` 这些值的累加结果。

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        int n = sc.nextInt();
        int[][] arr = new int[m][n];
        for (int i = 0; i < m; i ++) {
            for (int j = 0; j < n; j ++) {
                arr[i][j] = sc.nextInt();
            }
        }

        System.out.println(minPathSum1(arr));
    }

    private static int minPathSum1(int[][] arr) {
        if (arr == null || arr.length == 0 || arr[0] == null || arr[0].length == 0) {
            return 0;
        }

        int row = arr.length;
        int col = arr[0].length;
        int[][] dp = new int[row][col];
        dp[0][0] = arr[0][0];

        // base case
        for (int i = 1; i < row; i ++) {
            dp[i][0] = dp[i-1][0] + arr[i][0];
        }
        for (int j = 1; j < col; j ++) {
            dp[0][j] = dp[0][j-1] + arr[0][j];
        }

        // 状态转移方程
        for (int i = 1; i < row; i ++) {
            for (int j = 1; j < col; j ++) {
                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + arr[i][j];
            }
        }

        return dp[row-1][col-1];
    }
}
```

**空间压缩**：

我们在计算 `dp[i][j]` 的时候，只用到数组 dp 的第 i 行和 第 i-1 行，也就是说实际上只需要用两行的数组空间就可以计算出 dp。

这就是状态压缩的技巧。当我们发现每次状态转移只需要辅助表 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，从而实现进一步减少空间复杂度。

![](https://gitee.com/veal98/images/raw/master/img/20210526175716.png)

具体来讲，空间压缩就是：**在同一个空间位置，不停刷新值**，随着时间的推移，他的含义一直在变化，而他的值一直是对应他的含义。

比如说**按行滚动刷新**的方式，在处理第 1 行数字的时候，dp[j] 就表示从坐标 (0,0) 到坐标 (0,j) 的最小路径和；在处理第 2 行数字的时候，dp[j] 就表示从坐标 (0,0) 到坐标 (1,j) 的最小路径和；

同样的，**按列滚动刷新**的方式，在处理第 1 列数字的时候，dp[j] 就表示从坐标 (0,0) 到坐标 (j, 0) 的最小路径和；在处理第 2 列数字的时候，dp[j] 就表示从坐标 (0,0) 到坐标 (j, 1) 的最小路径和；

> 左神的解法对辅助数组的空间大小定义都做出了严格的要求。根据行数和列数的大小来决定按行滚动还是按列滚动，从而确定辅助数组的大小。
>
> 比如本题，假如说行数 m 大于列数 n，我们使用按行滚动的方式，则我们只需要开辟 dp[n] 的数组空间；如果使用按列滚动的方式，需要开始 dp[m] 的数组空间，显然按行滚动更好。

```java
private static int minPathSum2(int[][] arr) {
    if (arr == null || arr.length == 0 || arr[0] == null || arr[0].length == 0) {
        return 0;
    }

    int row = arr.length;
    int col = arr[0].length;

    int more = Math.max(row, col);  // 行数与列数较大的那个为 more
    int less = row == more ? col : row; // 行数与列数较小的那个为 less
    boolean rowmore = (more == arr.length); // 行数是不是大于或等于列数

    int[] dp = new int[less]; // 辅助数组的长度仅为行数与列数中的最小值
    dp[0] = arr[0][0];

    // base case
    for (int i = 1; i < less; i ++) {
        // 行数大于列数，则按行滚动；反之按列滚动
        dp[i] = dp[i-1] + (rowmore ? arr[0][i] : arr[i][0]);
    }

    // 状态转移方程
    for (int i = 1; i < more; i ++) {
        // dp[0] 的含义是不断变化的
        dp[0] = dp[0] + (rowmore ? arr[i][0] : arr[0][i]);
        for (int j = 1; j < less; j ++) {
            dp[j] = Math.min(dp[j-1], dp[j]) + (rowmore ? arr[i][j] : arr[j][i]);
        }
    }

    return dp[less-1];
}
```

##  斐波那契数列问题

> 严格来说，斐波那契数列问题并不算动态规划问题，因为它并没有涉及到最值的计算。

### CD183. 斐波那契数列问题的递归和动态规划

【题目链接】：

- NowCoder：[CD183. 斐波那契数列问题的递归和动态规划](https://www.nowcoder.com/practice/376282a6682a4005973cde7b3df69584?tpId=101&tqId=33251&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给出一个整数 n，请输出斐波那契数列的第 n 项对 1e9 + 7 取模的值。

斐波那契数列为 1,1,2,3,5,8, …

输入描述:

```
第一行一个整数 n。
```

输出描述:

```
输出第 n 项对于 1e9 + 7 取模的值。
```

示例1

```
输入
1

输出
1
```

【解题思路】：

1）方法一：暴力递归 — 时间复杂度 O(2^N)

```java
// 递归
private static int f1(int n) {
    if (n < 1) {
        return 0;
    }

    if (n == 1 || n == 2) {
        return 1;
    }

    return f1(n - 1) + f1(n - 2);
}
```

2）方法二：动态规划 — 时间复杂度 O(N)

**辅助数组定义**：题目要求斐波那契数列的第 n 项的值。所以我们定义一个辅助数组 `dp[i]` 表示斐波那契数列的第 i 项的值

**状态转移方程**：

`dp[i] = dp[i - 1] + dp[i - 2]`

**base case**：

`dp[0] = 0, dp[1] = 1`

```java
// 动态规划
private static int f2(int n) {
    if (n < 0) {
        return 0;
    }
    
    // 斐波那契数列的第 i 项的值是 dp[i]
    int[] dp = new int[n + 1];
    
    // base case
    dp[0] = 0;
    dp[1] = 1;
    
    // 状态转移方程
	for (int i = 2; i <= n; i ++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}
```

3）方法三：动态规划（空间压缩） — 时间复杂度 O(N)，空间复杂度 O(1)

注意到在状态转移方程中，`dp[i]` 的值只和 `dp[i - 1]`，`dp[i - 2]` 有关，因此我们可以使用三个变量进行状态转移，省去数组的空间：

```java
class Solution {
    public int fib(int n) {
        if (n < 1) {
            return 0;
        }

        if (n == 1 || n == 2) {
            return 1;
        }

        int t1 = 1; // dp[i-2]
        int t2 = 1; // dp[i-1]
        int t3 = 1; // dp[i]
        for (int i = 3; i <= n; i ++) {
            t3 = t1 + t2;
            t1 = t2;
            t2 = t3;
        }
        return t3;
    }
}
```

事实上，上述这样写确实更容易理解，但是其实我们只使用两个变量就行了（斐波那契数列可以从左到右依次求出每一项的值，那么我们只需要记录第 N 项的前两项的值即可）：

```java
// 记录前两项的值
private static int f3(int n) {
    if (n < 1) {
        return 0;
    }

    if (n == 1 || n == 2) {
        return 1;
    }

    int t1 = 1; // 第一个数
    int t2 = 1; // 第二个数
    for (int i = 3; i <= n; i ++) {
        int temp = t2; // 保存第二个数一开始的值
        t2 = t2 + t1; // 计算第三个数的值
        t1 = temp; // 进入下一个数的计算
    }
    return t2;
}
```

4 - 选看）方法四：加速矩阵乘法的动态规划 — 时间复杂度 O(logN)

这里先给出一条结论：

⭐ 如果递归式严格符合 `F(n)=a×F(n-1) + b×F(n-2) + ... + k×F(n-i)`，那么它就是一个 i 阶的递推式，必然有与 `i×i` 的状态矩阵有关的矩阵乘法的表达。一律可以用**加速矩阵乘法的动态规划**将时间复杂度降为 O(logN)

![](https://gitee.com/veal98/images/raw/master/img/20210523170605.png)

> （1 x 2 的矩阵）=（1 x 2 的矩阵）X（2 x 2 的矩阵）

把 F(1)==1, F(2)==1, F(3)==2, F(4)==3 代入，求出状态矩阵：

![](https://gitee.com/veal98/images/raw/master/img/20210523170643.png)

我们记上图红色框中结果为 res，则 `F(n) = 1 * res[0][0] + 1 * res[1][0]`



所以，求斐波那契数列第N项的问题就变成了如何用最快的方法求一个矩阵N次方的问题，而求矩阵N次方的问题明显是一个能够在O(logN)时间内解决的问题。

为了表述方便，我们现在用求一个整数 N 次方的例子来说明，因为只要理解了如何在 O(logN)的时间复杂度内求整数 N次方的问题，对于求矩阵 N 次方的问题是同理的，区别是矩阵乘法和整数乘法在细节上有些不一样，但对于怎么乘更快，两者的道理相同。

![](https://gitee.com/veal98/images/raw/master/img/20210523170742.png)



按照这种解法，这里给出本题的完整代码。根据题意，需要对结果进行 1e9 + 7 取模

```java
public class Main {
    
    private static long mod = 1000000007;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long N = sc.nextLong();
        System.out.println(f4(N));
    }

    // 加速矩阵乘法的动态规划
    private static long f4(long n) {
        if (n < 1) {
            return 0;
        }

        if (n == 1 || n == 2) {
            return 1;
        }

        long[][] base = {{1,1}, {1, 0}};
        long[][] res = matrixPower(base, n - 2);
        return (res[0][0] + res[1][0]) % mod;
    }

    // 求矩阵 m 的 p 次方
    private static long[][] matrixPower(long[][] m, long p) {
        long[][] res = new long[m.length][m[0].length];

        // base case(单位矩阵)
        for (int i = 0; i < res.length; i ++) {
            res[i][i] = 1;
        }

        long[][] temp = m;
        for (; p != 0; p = p >> 1) {
            if ((p & 1) != 0) {
                // 对应到 p 的二进制数中，相应的位上是 1, 则进行累乘
                res = multiMatrix(res, temp);
            }
            temp = multiMatrix(temp, temp);
        }

        return res;
    }

    // 两个矩阵相乘
    private static long[][] multiMatrix(long[][] m1, long[][] m2) {
        long[][] res = new long[m1.length][m2[0].length];

        for (int i = 0; i < m1.length; i ++) {
            for (int j = 0; j < m2[0].length; j ++) {
                for (int k = 0; k < m2.length; k ++) {
                    res[i][j] += m1[i][k] * m2[k][j];
                    res[i][j] = res[i][j] % mod;
                }
            }
        }

        return res;
    }
}
```

### CD184. 跳台阶问题的递归和动态规划

【题目链接】：

- NowCoder：[CD184. 斐波那契数列问题的递归和动态规划 2](https://www.nowcoder.com/practice/fd66768dc08748f2be6626f07a02e466?tpId=101&tqId=33252&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给出一个整数 n，代表台阶数，一次可以跨 2 个或者 1 个台阶，请输出有多少种走法。

输入描述:

```
第一行一个整数 n。
```

输出描述:

```
输出走法数对 1e9 + 7 取模的值。
```

示例1

```
输入
3

输出
3
```

【解题思路】：

如果台阶只有1级，方法只有1种。如果台阶有2级，方法有2种。

如果台阶有N级，最后跳上第 N 级的情况，要么是从 N-2 级台阶直接跨 2 级台阶，要么是从 N-1 级台阶跨 1 级台阶。

所以，台阶有 N 级的方法数为跨到 N-2 级台阶的方法数加上跨到N-1级台阶的方法数，即 S(N)=S(N-1)+S(N-2)，初始项 S(1)==1, S(2)==2。

所以，类似斐波那契数列，**唯一的不同就是初始项不同**。可以很轻易地写出 O(2^N)与O(N)的方法

1）方法一：暴力递归 — 时间复杂度 O(2^N)

```java
private static int f1(int n) {
    if (n < 1) {
        return 0;
    }

    if (n == 1 || n == 2) {
        return n;
    }

    return f1(n - 1) + f1(n - 2);
}
```

2）方法二：动态规划 — 时间复杂度 O(N)

**辅助数组定义**：定义一个辅助数组 `dp[i]` 表示如果有 N 级台阶，则有 dp[i] 种方法走法

**状态转移方程**：

`dp[i] = dp[i - 1] + dp[i - 2]`

**base case**：

`dp[0] = 0, dp[1] = 1, dp[2] = 2`

```java
// 动态规划
private static int f2(int n) {
    if (n < 1) {
        return 0;
    }
    
    // 斐波那契数列的第 i 项的值是 dp[i]
    int[] dp = new int[n + 1];
    
    // base case
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;
    
    // 状态转移方程
	for (int i = 3; i <= n; i ++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}
```

3）方法三：动态规划（空间压缩） — 时间复杂度 O(N)，空间复杂度 O(1)

```java
private static int f3(int n) {
    if (n < 1) {
        return 0;
    }

    if (n == 1 || n == 2) {
        return n;
    }

    int t1 = 1; // 第一个数
    int t2 = 2; // 第二个数
    for (int i = 3; i <= n; i ++) {
        int temp = t2; // 保存第二个数一开始的值
        t2 = t1 + t2; // 计算第三个数的值
        t1 = t2; // 进入下一个数的计算
    }

    return t2;
}
```

4 - 选看）方法四：加速矩阵乘法的动态规划 — 时间复杂度 O(logN)

表达式 S(n)=S(n-1)+S(n-2)是一个二阶递推数列，同样，使用矩阵乘法加速递推。

根据前 4 项S(1)==1, S(2)==2,S(3)==3, S(4)==5，可以得到：

![](https://gitee.com/veal98/images/raw/master/img/20210525124727.png)

我们记上图红色框中结果为 res，则 `S(n) = 2 * res[0][0] + 1 * res[1][0]`

```java
public class Main {
    
    private static long mod = 1000000007;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long n = sc.nextLong();

        System.out.println(f4(n));
    }

    private static long f4(long n) {
        if (n < 1) {
            return 0;
        }

        if (n == 1 || n == 2) {
            return n;
        }

        long[][] base = {{1, 1}, {1, 0}};
        long[][] res = matrixPower(base, n - 2);

        return (2 * res[0][0] + res[1][0]) % mod;
    }

    // 求矩阵 m 的 p 次方
    private static long[][] matrixPower(long[][] m, long p) {
        ......
    }

    // 两个矩阵相乘
    private static long[][] multiMatrix(long[][] m1, long[][] m2) {
    	......
    }
}
```

### CD185. 母牛生产问题的递归和动态规划

【题目链接】：

- NowCoder：[CD185. 斐波那契数列问题的递归和动态规划 3](https://www.nowcoder.com/practice/e2696bb900ce41cda8b060768e61f796?tpId=101&tqId=33253&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

假设农场中成熟的母牛每年只会生 1 头小母牛，并且永远不会死。第一年农场中有一只成熟的母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 n，求出 n 年后牛的数量。

输入描述:

```
输入一个整数 n。
```

输出描述:

```
输出 n 年后牛的数量对 1e9 + 7 取模的值。
```

示例 1

```
输入
6

输出
9
```

【解题思路】：

第 N-3 年的所有牛，到第 N 年肯定都是成熟的牛，又可以生小母牛。C(n)=C(n-1)+C(n-3)

1）方法一：暴力递归 — 时间复杂度 O(2^N)

```java
private static int f1(int n) {
    if (n < 1) {
        return 0;
    }

    if (n == 1 || n == 2 || n == 3) {
        return n;
    }

    return f1(n - 1) + f1(n - 3);
}
```

2）方法二：动态规划 — 时间复杂度 O(N)

**辅助数组定义**：定义一个辅助数组 `dp[i]` 表示如果有 N 级台阶，则有 dp[i] 种方法走法

**状态转移方程**：

`dp[i] = dp[i - 1] + dp[i - 3]`

**base case**：

`dp[0] = 0, dp[1] = 1, dp[2] = 2, dp[3] = 3`

```java
// 动态规划
private static int f2(int n) {
    if (n < 0) {
        return 0;
    }

    // 斐波那契数列的第 i 项的值是 dp[i]
    int[] dp = new int[n + 1];

    // base case
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 3;

    // 状态转移方程
    for (int i = 4; i <= n; i ++) {
        dp[i] = dp[i - 1] + dp[i - 3];
    }

    return dp[n];
}
```

3）方法三：动态规划（空间压缩） — 时间复杂度 O(N)，空间复杂度 O(1)

```java
private static int f2(int n) {
    if (n < 1) {
        return 0;
    }

    if (n == 1 || n == 2) {
        return n;
    }

    int t1 = 1; // 第一个数
    int t2 = 2; // 第二个数
    for (int i = 3; i <= n; i ++) {
        int temp = t2; // 保存第二个数一开始的值
        t2 = t1 + t2; // 计算第三个数的值
        t1 = t2; // 进入下一个数的计算
    }

    return t2;
}
```

4 - 选看）方法四：加速矩阵乘法的动态规划 — 时间复杂度 O(logN)

根据递推式 C(n)=C(n-1)+C(n-3)，可知本题的状态矩阵应该是 3 阶的。

![](https://gitee.com/veal98/images/raw/master/img/20210525130514.png)

我们记上图红色框中结果为 res，则 `C(n) = 3 * res[0][0] + 2 * res[1][0] + res[2][0]`

```java
public class Main {
    
    private static long mod = 1000000007;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long n = sc.nextLong();

        System.out.println(f4(n));
    }


    private static long f4(long n) {
        if (n < 1) {
            return 0;
        }

        if (n == 1 || n == 2 || n == 3) {
            return n;
        }

        long[][] base = {{1, 1, 0}, {0, 0, 1}, {1, 0, 0}};
        long[][] res = matrixPower(base, n - 3);

        return (3 * res[0][0] + 2 * res[1][0] + res[2][0]) % mod;
    }

    // 求矩阵 m 的 p 次方
    private static long[][] matrixPower(long[][] m, long p) {
        ......
    }

    // 两个矩阵相乘
    private static long[][] multiMatrix(long[][] m1, long[][] m2) {
        ......
    }
}
```

### CD46/LC91. 数字字符转化为字母组合的种数

【题目链接】：

- NowCoder：[CD46. 数字字符转化为字母组合的种数](https://www.nowcoder.com/practice/6a5d7615332c49eb810c374dd6f37857?tpId=101&&tqId=33114&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)
- LeetCode：[91. 解码方法 — Medium](https://leetcode-cn.com/problems/decode-ways/)

【题目描述】：

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> 1

'B' -> 2

...

'Z' -> 26

要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

- "AAJF" ，将消息分组为 (1 1 10 6)
- "KJF" ，将消息分组为 (11 10 6)

注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。

示例 1：

```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```


示例 2：

```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```


示例 3：

```
输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
```


示例 4：

```
输入：s = "06"
输出：0
解释："06" 不能映射到 "F" ，因为字符串含有前导 0（"6" 和 "06" 在映射中并不等价）。
```

【解题思路】：

**辅助数组定义**：`dp[i]`表示字符 `str[0...i-1]` 转化为字母组合的种数

**状态转移方程**：

对于第 i 个数字（下标 i - 1）来说，有两种分类情况：

- 单独转换成字符（这个字符不能为 0）：`dp[i] = dp[i-1]`
- 和前一个数字组合转换成字符：`dp[i] = dp[i-2]`

<img src="https://gitee.com/veal98/images/raw/master/img/20210618223136.png" style="zoom: 60%;" />

总的递归公式其实这是这样，`dp[i] = dp[i - 1] + dp[i - 2]`

**base case**：

0 开头的数字必定无法转换成字符。

`dp[0] = 1, dp[1] = (str[0] == '0') ? 0 : 1`

【具体代码】：

```java
class Solution {
    public int numDecodings(String str) {
        char[] chs = str.toCharArray();

        // 特殊处理: 0 开头的字符无法转换
        if (chs[0] == '0') {
            return 0;
        }

        // dp[i] 表示 str[0...i-1] 可以转换成多少种字母的组合
        int[] dp = new int[chs.length + 1];

        // base case
        dp[0] = 1; // 空字符串只有 1 种解码方法，解码出一个空字符串
        dp[1] = 1; 

        // 状态转移方程
        for (int i = 2; i <= chs.length; i ++) {
            // 判断截取一个是否符合
            if (chs[i-1] != '0') {
                dp[i] = dp[i - 1];
            }
            // 判断截取两个是否符合
            int sum = (chs[i-2] - '0') * 10 + (chs[i-1] - '0');
            if (chs[i-2] != '0' && sum >= 10 && sum <= 26) {
                dp[i] += dp[i - 2];
            }
        }

        return dp[chs.length];
    }
}
```

**空间压缩**：注意到在状态转移方程中，`dp[i]` 的值只和 `dp[i - 1]`，`dp[i - 2]` 有关，因此我们可以使用三个变量进行状态转移，省去数组的空间。

```java
class Solution {
    public int numDecodings(String str) {
        char[] chs = str.toCharArray();

        // 特殊处理: 0 开头的字符无法转换
        if (chs[0] == '0') {
            return 0;
        }

        // dp[0] = 1;
        // dp[1] = 1; 
        int a = 1; // a = f[i-2],
        int b = 1; // b = f[i-1]
        int c = 1; // c = f[i]

        // 状态转移方程
        for (int i = 2; i <= chs.length; i ++) {
            c = 0;
            // 判断截取一个是否符合
            if (chs[i-1] != '0') {
                c = b;
            }
            // 判断截取两个是否符合
            int sum = (chs[i-2] - '0') * 10 + (chs[i-1] - '0');
            if (chs[i-2] != '0' && sum >= 10 && sum <= 26) {
                c += a;
            }
            a = b;
            b = c;
        }

        return c;
    }
}
```



## 背包问题

### ① 0-1 背包问题

#### 0-1 背包问题模板

【问题描述】：给你一个可装载重量为 `W` 的背包和 `N` 个物品，每个物品有重量和价值两个属性，且每个物品只有一件。其中第 `i` 个物品的重量为 `w[i]`，价值为 `v[i]`，现在让你用这个背包装物品，<u>且每个物品只能使用一次</u>，最多能装的价值是多少？

<img src="https://gitee.com/veal98/images/raw/master/img/20201007093550.png" style="zoom:50%;" />

<img src="https://gitee.com/veal98/images/raw/master/img/20201007100720.png" style="zoom:40%;" />

举个简单的例子，输入如下：

```
N = 3, W = 4
w = [2, 1, 3]
v = [4, 2, 3]
```

算法返回 6，选择前两件物品装进背包，总重量 3 小于 `W`，可以获得最大价值 6。

题目就是这么简单，一个典型的动态规划问题。这个题目中的**物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。这就是 0-1 背包这个名词的来历**。

【解题思路】：

**辅助表定义**：

`dp[i][w]`的定义如下：**对于前 `i` 个物品，当前背包的容量为 `w` (还能装入 `w` 重量的物品)，这种情况下可以装的最大价值是 `dp[i][w]`。**根据这个定义，我们想求的最终答案就是`dp[N][W]`。

比如说，如果 `dp[3][5] = 6`，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。

**base case**：

- 背包容量为空时（N=0），能装的最大价值为 0  即 `dp[0][..] = 0`
- 物品容量为空时（W=0），能装的最大价值为 0  即 `dp[..][0] = 0`

> 💡 在 Java 中，`dp = new int[N+1][W+1];` 会将 dp 数组全部初始化成 0，所以本题的 base case 不必在代码中手动实现~l

**状态转移方程**：

1）当前背包容量装不下第 `i` 个物品（下标为 i - 1），只能选择不装入背包，那么很显然，最大价值`dp[i][w]`应该等于`dp[i-1][w]`。

2）当前背包还有容量（选择加入还是不加入）：

- **如果你没有把这第 `i`个物品装入背包**，那么很显然，最大价值`dp[i][w]`应该等于`dp[i-1][w]`。

- **如果你把这第 `i` 个物品装入了背包**，那么`dp[i][w]`应该等于`dp[i-1][w-w[i-1]] + v[i-1]`。

根据上面的状态转移方程，在计算 `dp[i][w]` 之前，我们需要先计算 `dp[i-1][w]` 和 `dp[i-1][w-w[i-1]]` ，直接从 0 开始顺序遍历即可保证计算顺序。

```java
private int[] weight; // 物品对应重量 
private int[] value; // 物品对应价值

/**
 * 返回最大价值
 * @param W 背包最大承受的物品总重量
 * @param N 背包最多承受的物品总数量
 * @return
 */
public int Knapsack(int N, int W){
    int[][] dp = new int[N+1][W+1];
    for(int i = 1; i <= N; i ++){ // 状态 1：可选择的物品
        for(int w = 1; w <= W; w ++){ // 状态 2：背包容量
            // 挑选最佳选择存入辅助表
            if(w - weight[i-1] < 0) // 当前背包容量装不下，只能选择不装入背包
                dp[i][w] = dp[i-1][w];
            else{ // 装入或者不装入背包，择优
                dp[i][w] = Math.max(dp[i-1][w-weight[i-1]] + value[i-1], dp[i-1][w]);
            }
        }
    }
    return dp[N][W];
}
```

🚨 注意，我们传入的 N 必须要和物品的数量一致。

**空间压缩**：

根据上面的状态转移方程，在计算 `dp[i][w]` 之前，我们只需要计算 `dp[i-1][..]` 的值，因此我们可以将辅助数组 `dp` 从二维降到一维，去掉第 1 维（即 `i` 的那一维），节约空间复杂度。并且由判断条件可知只有在 `w - weight[i-1] >= 0` 时，才会考虑是否将该物品加入背包。

<u>此处辅助表 `dp[w]` 的定义相当于：对于容量为 w 的背包，能够装的最大价值 `dp[w]`</u>

⭐ 需要注意的是，**为保证每个物品只能使用一次，我们 <u>倒序</u> 遍历所有 `w` 的值，类似于递归的方式，这样在更新 `dp[w]` 的时候，`dp[w-weight[i-1]]` 的值尚未被修改，就不会出现一个物品重复使用的问题**。

所以我们只需要修改一下判断条件，**将 `w`  从 `W` 开始依次递减**，将代码压缩至一行：

```java
public int Knapsack(int N, int W){
    int dp = new int[W+1];
    for(int i = 1; i <= N; i ++){
        for(int w = W; w - weight[i-1] >= 0; w --)
        	dp[w] = Math.max(dp[w-weight[i-1]] + value[i-1], dp[w]);
    }
    return dp[W];
}
```

⭐ 这里解释一下为什么要倒序枚举（从大重量背包到小重量）：

因为 `w  > w-weight[i-1]`，所以第 `i` 次循环中，执行背包容量为 `j` 时，容量为 `w-weight[i-1]` 的背包已经计算过了，如果使用正序遍历，显然某些物品会被重复使用。

#### LC474. 一和零

【题目链接】：

- LeetCode：[474. Ones and Zeroes — Medium](https://leetcode-cn.com/problems/ones-and-zeroes/)

【题目描述】：

现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。

你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。**每个 0 和 1 至多被使用一次**。

**Example 1**：

```
Input: strs = ["10","0001","111001","1","0"], m = 5, n = 3
Output: 4
Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are "10","0001","1","0".
```

**Example 2**：

```
Input: strs = ["10","0","1"], m = 1, n = 1
Output: 2
Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".
```

【解题思路】：

翻译为 0-1 背包问题。0 和 1 的数量就是背包的容量，题目给出的 strs 数组中的字符串就是要放入背包中的物体，一个字符串包含的 0 和 1 的数量就是它的重量，要求的问题是最多能够放入多少个物体（字符串）— 价值，并且每个物体只能使用一次

**辅助数组定义**：

> 仿照 0-1 模板背包问题的 `dp[i][w]`：对于前 `i` 个物品，当前背包的容量为 `w` (还能装入 `w` 重量的物品)，这种情况下可以装的最大价值是 `dp[i][w]`。

`dp[i][j][k]` 表示对于前 i 个字符串（物品），当前背包中还能加入 j 个 0 和 k 个 1，这种情况下可以装的最多字符串（最大价值）是 `dp[i][j][k]` 个。

则我们最终所需要求的为 `dp[strs.length][m][n]`

**状态转移方程**：

1）当前剩余的背包容量装不下第 `i` 个物品/字符串（下标为 i - 1），只能选择不装入背包。也就是说当前剩余的 i、j 个数无法表示第 i 个字符串。那么很显然，最多字符串的个数 `dp[i][j][k]` 应该等于 `dp[i-1][w]`。

2）当前背包还有容量（选择加入还是不加入）：

- **如果你没有把这第  `i` 个字符串装入背包**，那么很显然，最大价值`dp[i][j][k]`应该等于`dp[i-1][j][k]`。

- **如果你把这第 `i` 个字符串装入了背包**，那么 `dp[i][j][k]` 应该等于`dp[i-1][j-countZero(i-1)][k-countOne(i-1)] + 1`。

**base case**：

k = 0 或者 i = 0 或者 j = 0 的时候，`dp[k][i][j] = 0`，在 Java 中 `new int[][][]` 的过程就会将该数组全部初始化成 0 了。

【具体代码】：

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        // 对于前 i 个字符串（物品），当前背包中还能加入 j 个 0 和 k 个 1
        // 这种情况下可以装的最多字符串（最大价值）是 dp[i][j][k] 个
        int[][][] dp = new int[strs.length + 1][m + 1][n + 1];

        // 状态转移方程
        for (int i = 1; i <= strs.length; i ++) {
            int[] counter = counterZeroAndOne(strs[i-1]); // 第 i 个字符串中 0 和 1 的数量
            for (int j = 0; j <= m; j ++) {
                for (int k = 0; k <= n; k ++) {
                    // 当前剩余的背包容量装不下第 i 个物品/字符串（下标为 i - 1），只能选择不装入背包
                    if (j < counter[0] || k < counter[1]) {
                        dp[i][j][k] = dp[i - 1][j][k];
                    }
                    // 当前背包还有容量, 可以选择装入也可以选择不转入
                    else {
                        dp[i][j][k] = Math.max(dp[i - 1][j][k], 
                                               dp[i - 1][j - counter[0]][k - counter[1]] + 1);
                    }
                }
            }
        }

        return dp[strs.length][m][n];
    }

    // 计算字符串中 0 和 1 的数量
    private int[] counterZeroAndOne(String str){
        int[] counter = new int[2];
        for(char c : str.toCharArray()){
            if(c == '0')
                counter[0] ++;
            else 
                counter[1] ++;
        }
        return counter;
    }
}
```

**空间压缩**：

对于上述代码，可以看出 `dp[i][][]` 只和 `dp[i-1][][]` 有关，所以可以去掉第一维 i，只用一个二维数组保存上一次计算的结果。并且由判断条件可知只有在 `j >= counter[0] && k >= counter[1]` 时，才会考虑是否可能表示该字符串。所以我们只需要修改一下判断条件，并且按照 0-1 背包问题模板解题里面说的，将循环改成逆序的：

```java
public int findMaxForm(String[] strs, int m, int n) {

    int[][] dp = new int[m + 1][n + 1];

    // 状态转移方程
    for (int i = 1; i <= strs.length; i ++) {
        int[] counter = counterZeroAndOne(strs[i-1]); // 第 i 个字符串中 0 和 1 的数量
        for (int j = m; j >= 0; j --) {
            for (int k = n; k >= 0; k --) {
                if (j >= counter[0] && k >= counter[1]) {
                     dp[j][k] = Math.max(dp[j][k], 
                                         dp[j - counter[0]][k - counter[1]] + 1);
                }
            }
        }
    }

    return dp[m][n];
}
```

#### LC416. 分割等和子集

【题目链接】：

- LeetCode：[416. Partition Equal Subset Sum — Medium](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

【题目描述】：

给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

示例 1：

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```


示例 2：

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

【解题思路】：

首先，题目要求将一个数组切割成两个和相等的子集，假设数组中所有元素的和记为 sum，则每个子集的和为 sum/2，可以得出：如果 sum 是奇数，那么一定无法将这个数组分割成两个和相等的子集。

显然，我们只需要找出一个和为 sum/2 的子集就行。

至此，这个题目就已经很明了了。 

翻译为 0-1 背包问题。sum / 2 就是背包的容量，题目给出的 nums 数组中的元素就是要放入背包中的物体，每个元素的值就是它的重量，要求的问题是能否把这个背包装满，并且每个物体只能使用一次。

**辅助数组定义**：

> 仿照 0-1 模板背包问题的 `dp[i][w]`：对于前 `i` 个物品，当前背包的容量为 `w` (还能装入 `w` 重量的物品)，这种情况下可以装的最大价值是 `dp[i][w]`。

`dp[i][j] = true/false` 表示对于前 i 个元素（物品），当前背包的容量为 j（还能装入 j 重量的元素），这种情况下，能否正好把背包装满（子集和等于 j）。

比如说 `dp[4][9] = true` 其含义为：对于给定的集合中，若只对前 4 个数字进行选择，存在一个子集的和可以恰好凑出 9。

则我们最终所需要求的为 `dp[N][sum/2]`

**状态转移方程**：

1）当前剩余的背包容量装不下第 `i` 个物品/元素（下标为 i - 1），只能选择不装入背包。也就是说当前元素值大于背包的剩余容量。那么很显然，`dp[i][j]` 应该等于 `dp[i-1][j]`。

2）当前背包还有容量（选择加入还是不加入）：

- **如果你没有把这第  `i` 个元素装入背包**，那么很显然，`dp[i][j]`应该等于 `dp[i-1][j]`。

- **如果你把这第 `i` 个元素装入了背包**，那么 `dp[i][j]` 应该等于 `dp[i-1][j-nums[i-1]]`。就是说如果你把这第 **`i`** 个物品装入了背包使得重量恰好为 `j`，那就意味着在 `[0, i - 1]` 这个子区间内得找到一部分元素，使得它们的和为 `j - nums[i-1]`。 

**base case**：

`dp[i][0] = true`，即背包容量为 0 时，啥也不装就行了。

`dp[0][j] = false`，当没有物品（数字）可选择的时候，肯定没办法装满背包。

【具体代码】：

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0; // 数组所有元素的和
        for (int i = 0; i < nums.length; i ++) {
            sum += nums[i];
        }
        // 如果 sum 为奇数, 则一定无法将这个数组分割成两个和相等的子集
        if (sum % 2 != 0) {
            return false;
        }

        boolean[][] dp = new boolean[nums.length + 1][sum/2 + 1];
    
        // base case
        for (int i = 0 ; i <= nums.length; i ++) {
            dp[i][0] = true;
        }

        // 状态转移方程
        for (int i = 1; i <= nums.length; i ++) {
            for (int j = 1; j <= sum/2; j ++) {
                // 当前剩余的背包容量装不下第 i 个物品
                if (j < nums[i-1]) {
                    dp[i][j] = dp[i - 1][j];
                }
                // 当前背包还有容量
                else {
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i-1]];
                }
            }
        }

        return dp[nums.length][sum/2];
    }
}
```

**空间压缩**：

对于上述代码，可以看出 `dp[i][]` 只和 `dp[i-1][]` 有关，所以可以去掉第一维 i，只用一个二维数组保存上一次计算的结果。并且由判断条件可知只有在 `j >= nums[i-1]` 时，才会考虑是否可能加入该元素。所以我们只需要修改一下判断条件，并且按照 0-1 背包问题模板解题里面说的，将循环改成逆序的：

此处辅助表 `dp[j] = false/true` 的定义相当于：对于总和为 j 的数组（容量为 j 的背包），是否能够将这个背包正好装满。

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0; // 数组所有元素的和
        for (int i = 0; i < nums.length; i ++) {
            sum += nums[i];
        }
        // 如果 sum 为奇数, 则一定无法将这个数组分割成两个和相等的子集
        if (sum % 2 != 0) {
            return false;
        }

        boolean[] dp = new boolean[sum/2 + 1];
    
        // base case
        dp[0] = true;

        // 状态转移方程
        for (int i = 1; i <= nums.length; i ++) {
            for (int j = sum/2; j >= 1; j --) {
                if (j >= nums[i-1]) {
                    dp[j] = dp[j] || dp[j - nums[i-1]];
                }
            }
        }

        return dp[sum/2];
    }
}
```

### ② 完全背包问题

#### 完全背包问题模板（LC518. 零钱兑换 II）

有 N 种物品和一个容量为 W 的背包，每种物品都有无限个，第 `i` 种物品的价值为 `v[i]`，重量为 `w[i]`，求解：选哪些物品放入背包，可使得背包中的价值最大，并且不超过背包容量。

💡 显然，和 0-1 背包问题最大的不同点就在于：**完全背包问题中的物品拥有无限个**

我们直接以 LeetCode 中的实例分析：

【题目链接】：

- LeetCode：[518. 零钱兑换 II — Medium](https://leetcode-cn.com/problems/coin-change-2/)

【问题描述】：

❓ 给定不同面额的硬币和一个总金额。写出函数来<u>计算可以凑成总金额的硬币组合数</u>。假设**每一种面额的硬币有无限个**。 

示例 1:

```
输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```


示例 2:

```
输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。
```


示例 3:

```
输入: amount = 10, coins = [10] 
输出: 1
```

【解题思路】：

把这个问题转化为背包问题的描述形式：<u>有一个背包，最大容量为 `amount`，有一系列物品 `coins`，每个物品的重量为 `coins[i]`，**每个物品的数量无限**。请问有多少种方法，能够把背包恰好装满 ？</u>

**辅助数组定义**：`dp[i][j]` 的定义如下，对于前`i`个物品，当前背包的容量为 `j` (还能装入 `j` 重量的物品/硬币)，有 `dp[i][j]` 种方法可以装满背包。

 比如说，如果 `dp[3][5] = 6`，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，有 6 种方法可以装满背包。

根据这个定义，我们想求的最终答案就是 `dp[coins.length][amount]`。

**状态转移方程**：

1）背包容量不足以装入第 `i` 个物品/硬币，只能选择不装入，即`dp[i][j]` 应该等于 `dp[i-1][j]`

2）背包容量足够装入第 `i` 个物品：

- 如果你没有把这第 `i`个物品（下标 `i-1` ）装入背包，那么很显然，`dp[i][j]` 应该等于 `dp[i-1][j]`。

- 如果你把这第 `i` 个物品装入了背包，那么 `dp[i][j]` 应该等于 `dp[i][j-coins[i-1]]`。

  > 🚨 注意 这个地方和 0-1 背包不一样，并不是 `dp[i-1]`[j-coins[i-1]] 而是 `dp[i]`[j-coins[i-1]]。
  >
  > 首先，如果将第 `i` 个硬币（面值 `coins[i-1]`）装入背包，等价于先凑出金额  `j-coins[i-1]` 再加上第 `i` 个硬币即可。<u>由于硬币个数是无限的，加入第 `i` 个硬币后，它不仅可以放在最后和 `j-coins[i-1]` 凑成金额 `j`，还可以用来凑金额 `j-coins[i-1]`</u>。

需要额外注意的是：题目中要求的是总共有多少种解法，因此应该将装入第 `i` 个物品和不装入第 `i` 个物品的解法数相加起来。

**base case**：

- `dp[i][0] = 1`，背包容量为空时，只有一种装法即不装入任何硬币
- `dp[0][..] = 0`，硬币数量为空时，无法凑出任何金额

【具体代码】：

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[][] dp = new int[coins.length + 1][amount + 1];

        // base case
        for (int i = 0; i <= coins.length; i ++) {
            dp[i][0] = 1;
        }

        // 状态转移方程
        for (int i = 1; i <= coins.length; i ++) {
            for (int j = 1; j <= amount; j ++) {
                // 当前剩余的背包容量装不下第 i 个物品
                if (j < coins[i - 1]) {
                    dp[i][j] = dp[i - 1][j];
                }
                // 当前背包还有容量
                else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]];
                }
            }
        }

        return dp[coins.length][amount];
    }
}
```

**状态压缩**：

压缩的基本套路和 0-1 背包问题差不多，这里不再多说了。需要注意的是，与上述 0-1 背包的优化算法相反，我们**正序**遍历 `j` （即保持循环条件不变），正好可以实现每种物品的无限使用，即相当于每种物品有无限个：

<u>此处辅助表 `dp[j]` 的定义相当于：对于容量为 `j` 的背包（总金额），总共有  `dp[j]` 种方法能够恰好装满</u>

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];

        // base case
        dp[0] = 1;

        // 状态转移方程
        for (int i = 1; i <= coins.length; i ++) {
            for (int j = 1; j <= amount; j ++) {
                if (j >= coins[i - 1]) {
                    dp[j] = dp[j] + dp[j - coins[i - 1]];
                }
            }
        }

        return dp[amount];
    }
}
```

#### CD12/LC322. 零钱兑换

【题目链接】：

- NowCoder：[CD12. 换钱的最少货币数](https://www.nowcoder.com/practice/4e05294fc5aa4d4fa8eacef2e606e5a8?tpId=101&&tqId=33080&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)
- LeetCode：[322. 零钱兑换 — Medium](https://leetcode-cn.com/problems/coin-change/)

【题目描述】：

给定数组 arr，arr 中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个 aim，代表要凑出来的面额，求组成 aim 的最少货币数。

输入描述：

输入包括两行，第一行两个整数 n（0<=n<=1000）代表数组长度和aim（0<=aim<=5000），第二行 n 个不重复的正整数，代表 $arr\left( 1 \leq arr_i \leq 10^9 \right)$。

输出描述：

输出一个整数，表示组成 aim 的最小货币数，无解时输出-1.

示例 1：

```
输入：
3 20
5 2 3

输出：
4

说明：
20=5*4
```

示例 2

```
输入：
3 0
5 2 3

输出：
0
```

示例 3

```
输入：
2 2
3 5

输出：
-1
```

【解题思路】：

把这个问题转化为背包问题的描述形式：有一个背包，最大容量为 `aim`，有一系列物品（每种面值的货币），每个物品/元素的重量为 `arr[i]`，**每个物品的数量无限**。请问最少放入多少个物品，能够把背包恰好装满 ？

**辅助数组定义**：`dp[i][j]` 的定义如下，对于前 `i` 个物品，当前背包的容量为 `j` (还能装入 `j` 重量的物品/硬币)，最少需要放入 `dp[i][j]` 个物品才可以装满背包。

 比如说，如果 `dp[3][5] = 6`，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最少需要放入 6 个物品可以装满背包。

根据这个定义，我们想求的最终答案就是 `dp[arr.length][aim]`。

**状态转移方程**：

1）背包容量不足以装入第 `i` 个物品/硬币，只能选择不装入，即`dp[i][j]` 应该等于 `dp[i-1][j]`

2）背包容量足够装入第 `i` 个物品：

- 如果你没有把这第 `i`个物品（下标 `i-1` ）装入背包，那么很显然，`dp[i][j]` 应该等于 `dp[i-1][j]`。

- 如果你把这第 `i` 个物品装入了背包，那么 `dp[i][j]` 应该等于 `dp[i][j-arr[i-1]] + 1`。

**base case**：

- `dp[i][0] = 0`，背包容量为空时，不装入任何货币
- `dp[0][j] = 0x3f3f3f3f`（0x3f3f3f3f 表示无穷大），硬币数量为空时，无法凑出任何金额，这里我们不初始化为  0 了，顺应题意，**我们将其初始化为无穷大**，方便判断无解时输出 -1。

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 数组长度
        int aim = sc.nextInt();

        int[] arr = new int[n];
        for (int i = 0; i < n; i ++) {
            arr[i] = sc.nextInt();
        }
        System.out.println(coinChange(arr, aim));
    }

    private static int coinChange(int[] arr, int aim) {
        int[][] dp = new int[arr.length + 1][aim + 1];

        // base case
        for(int i = 1; i <= aim; i ++){
            dp[0][i] = 0x3f3f3f3f;
        }

        // 状态转移方程
        for (int i = 1; i <= arr.length; i ++) {
            for (int j = 1; j <= aim; j ++) {
                // 当前剩余的背包容量装不下第 i 个物品
                if (j < arr[i - 1]) {
                    dp[i][j] = dp[i - 1][j];
                }
                // 当前背包还有容量
                else {
                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j - arr[i-1]] + 1);
                }
            }
        }

        return dp[arr.length][aim] < 0x3f3f3f3f ? dp[arr.length][aim] : -1;
    }

}
```

**状态压缩**：

不再多说了，直接上代码。

<u>此处辅助表 `dp[j]` 的定义相当于：对于容量为 `j` 的背包（总金额），最少需要放入  `dp[j]` 个货币才能够恰好装满</u>

```java
private static int coinChange(int[] arr, int aim) {
    int[] dp = new int[aim + 1];

    // base case
    // dp[0] = 0;
    for(int i = 1; i <= aim; i ++){
        dp[i] = 0x3f3f3f3f;
    }

    // 状态转移方程
    for (int i = 1; i <= arr.length; i ++) {
        for (int j = 1; j <= aim; j ++) {
            if (j >= arr[i - 1]) {
                dp[j] = Math.min(dp[j], dp[j - arr[i-1]] + 1);
            }
        }
    }

    return dp[aim] < 0x3f3f3f3f ? dp[aim] : -1;
}
```

### ③ 带顺序的完全背包问题

#### 带顺序的完全背包问题模板（LC377. 组合总和 Ⅳ）

以下面这个题目为例 

【题目链接】：

- LeetCode：[377. 组合总和 Ⅳ — Medium](https://leetcode-cn.com/problems/combination-sum-iv/)

【题目描述】：

给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

示例：

```
nums = [1, 2, 3]
target = 4

所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
```

请注意，**顺序不同的序列被视作不同的组合**。

因此输出为 7。

⭐ 翻译成背包问题的语法就是：<u>有一个背包，最大容量为 `target`，有一系列物品 `nums`，每个物品的重量为 `nums[i]`，**每个物品的数量无限**。请问有多少种方法，能够把背包恰好装满 。注意**物品装入顺序不同的方法被视为不同的方法**</u>

> 这类问题有个小坑，就是**只能使用一维的辅助数组，因为选出来的物品并不影响后续取哪个物品**。即我们上述所说的二维辅助数组的第一维（可选择的物品）是无法使用的。这样也好，直接套空间压缩后的模板吧

和上述完全背包问题的代码基本完全一致，🚨 不过**由于涉及到顺序问题，所以需要将对于物品的循环放在内循环**：

```java
for(int j = 1; j <= target; j ++){ // 对容量的循环
    for(int i = 1; i <= len; i ++){ // 对物品的循环
```

<u>此处的辅助表 `dp[j]` 理解为：对于容量为 `j` 的背包，有 `dp[j]` 种方法可以装满。</u>

OK，其余的直接抄代码就行了

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        // dp[j] 表示如果目标整数(背包容量)是 target, 有 dp[j] 种方法可以填满背包
        int[] dp = new int[target + 1];

        // base case
        dp[0] = 1;

        // 状态转移方程
        for (int j = 1; j <= target; j ++) {
            for (int i = 1; i <= nums.length; i ++) {
                if (j >= nums[i - 1]) {
                    dp[j] = dp[j] + dp[j - nums[i-1]];
                }
            }
        }

        return dp[target];
    }
}
```

## 子数组、子序列问题

子数组（子串）必须是连续的，而序列可以不是连续的。比如 ABC，AB 就是一个子串，当然你也可以称呼它为序列，但是 AC 就不是子串。

### ① 子序列问题

#### CD25/LC300. 最长递增子序列 LIS

【题目链接】：

- NowCoder：[CD25. 最长递增子序列](https://www.nowcoder.com/practice/30fb9b3cab9742ecae9acda1c75bf927?tpId=101&&tqId=33093&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)
- LeetCode：[300 - 最长上升子序列 — Medium](计算机基础/算法/LeetCode/动态规划/300-最长上升子序列.md)

【题目描述】：

给定数组 arr，设长度为n，输出 arr 的最长递增子序列。（如果有多个答案，请输出其中字典序最小的）

输入描述：

输出两行，第一行包括一个正整数n（n<=100000），代表数组长度。第二行包括n个整数，代表数组 $arr \left(1 \leq arr_i \leq 1e9 \right)$。

输出描述：

输出一行。代表你求出的最长的递增子序列。

示例 1

```
输入：
9
2 1 5 3 6 4 8 9 7

输出：
1 3 4 8 9
```

示例 2

```
输入：
5
1 2 8 6 4

输出：
1 2 4

说明：
其最长递增子序列有3个，（1，2，8）、（1，2，6）、（1，2，4）其中第三个字典序最小，故答案为（1，2，4）
```

【解题思路】：

对于动态规划问题来说，我们最终的目标一般是求出一个最值，而本题要求的是一个数组，所以最后还需要我们对求出来的最值做一些处理。

**辅助数组的定义**：`dp[i]` 表示在以 arr[i] 这个数结尾的情况下，arr[0..i] 中的最大递增子序列长度。

**状态转移方程**：

如果最长递增子序列以 arr[i] 结尾，那么在 arr[0..i-1] 中所有比 arr[i] 小的数都可以作为倒数第二个数。<u>在这么多倒数第二个数的选择中，以哪个数结尾的最大递增子序列更大，就选哪个数作为倒数第二个数</u>，所以  `dp[i] = max{dp[j] + 1}, (0 <= j < i, arr[j] < arr[i])`。如果 arr[0..i-1] 中所有的数都不比 arr[i] 小，令 dp[i]=1 即可，说明以 arr[i] 结尾情况下的最长递增子序列只包含 arr[i]。

**base case**：

`dp[i] = 1`，上面已经解释过了，就是说以 arr[i] 这个数结尾的最长递增子序列长度至少是 1（因为子序列最少也要包含自己）。

这样，我们获取 dp 数组的代码是这样的：

```java
// 返回 dp 数组
private static int[] getDP(int[] arr) {
    // dp[i] 表示在以 arr[i] 这个数结尾的情况下，arr[0..i] 中的最大递增子序列长度
    int[] dp = new int[arr.length];

    // base case
    for (int i = 0; i < arr.length; i ++) {
        dp[i] = 1;
    }

    // 状态转移方程
    for (int i = 1; i < arr.length; i ++) {
        for (int j = 0; j < i; j ++) {
            if (arr[j] < arr[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }

    return dp;
}
```

如果想要获取最长递增子序列的长度，需要遍历一遍 dp 数组取最大值：

```java
// 遍历 dp 数组，找到最长递增子序列的长度（以哪个数结尾）
int maxLen = 0;// 最长递增子序列的长度
int index = 0; // 最长递增子序列最后一个数的下标
for (int i = 0; i < dp.length; i ++) {
    // 由于题目有字典序最小的要求，= 是必须的
    if (dp[i] >= maxLen) {
        maxLen = dp[i];
        index = i;
    }
}
```

> **当 dp[i] 和 dp[j] 相同时，假设 j 在 i 右边，那必然有 arr[j] < arr[i]**。所以题目中字典序最小的要求，在 maxLen 的判断中加个 = 即可。

而题目需要我们具体的给出最长递增子序列，因此我们还需要做一些处理。

以题目的例子来说明， arr=[2,1,5,3,6,4,8,9,7]，求出的数组 dp=[1,1,2,2,3,3,4,5,4]。

- 遍历 dp 数组，找到最长递增子序列的长度 5 以及最长递增子序列最后一个数的下标  7
- 从 ar r数组的位置 7 开始从右向左遍历。如果对某一个位置i，既有 arr[i] < arr[7]，又有 dp[i]==dp[7]-1，说明 arr[i] 可以作为最长递增子序列的倒数第二个数。在本例中，arr[6] < arr[7]，并且dp[6]==dp[7]-1，所以8应该作为最长递增子序列的倒数第二个数。
- 从 arr 数组的位置 6 开始继续向左遍历，按照同样的过程找到倒数第三个数 ......

整体代码如下：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 数组长度
        int[] arr = new int[n];
        for (int i = 0; i < n; i ++) {
            arr[i] = sc.nextInt();
        }

        int[] dp = getDP(arr);
        int[] lis = generateLIS(arr, dp);

        for (Integer i : lis) {
            System.out.print(i + " ");
        }
    }

    // 返回 dp 数组
    private static int[] getDP(int[] arr) {
        // dp[i] 表示在以 arr[i] 这个数结尾的情况下，arr[0..i] 中的最大递增子序列长度
        int[] dp = new int[arr.length];

        // base case
        for (int i = 0; i < arr.length; i ++) {
            dp[i] = 1;
        }

        // 状态转移方程
        for (int i = 1; i < arr.length; i ++) {
            for (int j = 0; j < i; j ++) {
                if (arr[j] < arr[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }

        return dp;
    }

    private static int[] generateLIS(int[] arr, int[] dp) {
        // 遍历 dp 数组，找到最长递增子序列的长度（以哪个数结尾）
        int maxLen = 0;
        int index = 0; // 最长递增子序列最后一个数的下标
        for (int i = 0; i < dp.length; i ++) {
            // 由于题目有字典序最小的要求，= 是必须的
            if (dp[i] >= maxLen) {
                maxLen = dp[i];
                index = i;
            }
        }

        int[] lis = new int[maxLen]; // 存储最长递增子序列
        lis[--maxLen] = arr[index];

        // 找到最长递增子序列的倒数第 2、3、4 ...个数
        for (int i = index; i >= 0; i --) {
            if (arr[i] < arr[index] && dp[i] + 1 == dp[index]) {
                lis[--maxLen] = arr[i];
                index = i;
            }
        }

        return lis;
    }
}
```

遗憾的是，这套代码在牛客网上超时了，很显然，计算 dp 数组的动态规划的时间复杂度为 O(N^2)，根据 dp 数组得到最长递增子序列过程的时间复杂度为 O(N)，所以整个过程的时间复杂度为 O(N^2)。

<br>

现在我们来想个办法优化下计算 dp 数组的动态规划过程的时间复杂度，让其降到 O(NlogN)

![](https://gitee.com/veal98/images/raw/master/img/20210602222123.png)

![](https://gitee.com/veal98/images/raw/master/img/20210602222240.png)

```java
// 二分查找优化
private static int[] getDP2(int[] arr) {
    // dp[i] 表示在以 arr[i] 这个数结尾的情况下，arr[0..i] 中的最大递增子序列长度
    int[] dp = new int[arr.length];
    dp[0] = 1;

    // ends[b] == c 表示:遍历到目前为止,在所有长度为 b+1 的递增序列中，最小的结尾数是 c
    int[] ends = new int[arr.length];
    ends[0] = arr[0];
    int right = 0;

    for (int i = 1; i < arr.length; i ++) {
        // 二分查找到 ends 数组中最左边大于或等于 arr[i] 的数
        int l = 0;
        int r = right;
        while (l <= r) {
            int m = (l + r) / 2;
            if (arr[i] > ends[m]) {
                l = m + 1;
            }
            else {
                r = m - 1;
            }
        }
        // 扩大有效区
        right = Math.max(right, l);
        ends[l] = arr[i];

        dp[i] = l + 1;
    }

    return dp;
}
```

#### CD29. 信封嵌套问题

【题目链接】：

- NowCoder：[CD29. 信封嵌套问题](https://www.nowcoder.com/practice/9b9fe43a92b74408988e20331b10f6b4?tpId=101&&tqId=33097&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)

【题目描述】：

给 n 个信封的长度和宽度。如果信封 A 的长和宽都小于信封 B，那么信封 A 可以放到信封 B 里，请求出信封最多可以嵌套多少层。

输入描述：

输出包含多行，第一行包括一个整数，代表信封的个数n (1≤*n*≤105)。接下来n行，每行两个整数 $l_i$和$w_i$，代表信封的长度和宽度 $\left( -1e9\leq l_i,w_i \leq 1e9 \right)$。

输出描述：

输出包括一行，代表信封最多嵌套多少层。

示例 1

```
输入：
9
3 4
2 3
4 5
1 3
2 2
3 6
1 2
3 2
2 4

输出：
4

说明：
从里到外分别是{1，2}，{2，3}，{3，4}，{4，5}。 
```

示例2

```
输入：
2
1 4
4 1

输出：
1
```

备注：

```
时间复杂度 O(nlogn)，空间复杂度 O(n)。
```

【解题思路】：

本题的关键，就是把信封数组按照一定的策略进行排序，转换成最长递增子序列问题。

排序规则是这样的：按照长度从小到大排序，长度相等的信封之间按照宽度从大到小排序。

这样排序的好处就在于：我们可以忽略长度，只看宽度数组。

为什么呢？

我们假设有一个信封 X，处在这个排序之后数组中的某个位置，长度为 Xlen，宽度为 Xwid。我们要求出必须以 X 作为最外面信封的情况下，最多套几层。那么信封 X 之后的信封一定不能放在 X 里，因为之后信封的长度都大于或等于 Xlen。

分析一下信封 X 之前的信封，因为排序策略是按照长度从小到大排序的，所以X之前的信封长度要么小于X，要么等于X：

1）如果 X 之前的信封长度小于X的长度。那么只要之前信封的宽度小于X的宽度，一定可以放在 X 内。所以在宽度组成的数组中，X 的宽度如果作为最后一个数，求宽度数组的最长递增子序列即可。

2）如果X之前的信封长度等于X的长度。因为长度相等的信封之间按照宽度从大到小排序，所以这些信封的宽度一定大于或等于X的宽度，这样就不可能是X的宽度作为最后一个数的情况下，宽度数组的最长递增子序列的一部分。

**所以，只需要求 X 的宽度作为最后一个数的情况下，宽度数组的最长递增子序列长度即可**

![](https://gitee.com/veal98/images/raw/master/img/20210607153342.png)

【具体代码】：

```java
public class CD29 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 信封的个数
        int[][] envelopes = new int[n][2];
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < 2; j ++) {
                envelopes[i][j] = sc.nextInt();
            }
        }

        // 对信封数组进行排序 (长度从小到大，宽度从大到小)
        Arrays.sort(envelopes, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if (o1[0] == o2[0]) {
                    return o2[1] - o1[1];
                }
                else {
                    return o1[0] - o2[0];
                }
            }
        });

        // 求宽度数组的最长递增子序列长度
        System.out.println(getMaxEnvelopes(envelopes));
    }

    // 求 envelopes[..][1] 的最长递增子序列
    private static int getMaxEnvelopes(int[][] envelopes) {
        // dp[i] 表示在以 envelopes[i][1] 这个数结尾的情况下，envelopes[0..i][1] 中的最大递增子序列长度
        int[] dp = new int[envelopes.length];

        // base case
        for (int i = 0; i < envelopes.length; i ++) {
            dp[i] = 1;
        }

        // 状态转移方程
        for (int i = 1; i < envelopes.length; i ++) {
            for (int j = 0; j < i; j ++) {
                if (envelopes[j][1] < envelopes[i][1]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }

        // 遍历 dp 数组，找到最长递增子序列的长度
        int res = 0;
        for (int i = 0; i < dp.length; i ++) {
            res = Math.max(dp[i], res);
        }
        
        return res;
    }
}
```

这套代码在牛客上没法 AC，因为题目要求时间复杂度是 O(nlogn)，各位把 LIS 改成二分查找优化那套代码就行了。

#### CD31/LC1143. 最长公共子序列 LCS

【题目链接】：

- [1143 - 最长公共子序列 — Medium](计算机基础/算法/LeetCode/动态规划/1143-最长公共子序列.md)
- [CD31. 最长公共子序列](https://www.nowcoder.com/practice/4727c06b9ee9446cab2e859b4bb86bb8?tpId=101&&tqId=33099&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)

【题目描述】：

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。

两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

示例 1：

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```


示例 2：

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
```


示例 3：

```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
```

【解题思路】：

**辅助数组的定义**：`dp[i][j]` 表示序列 text1[0...i] 和 text2[0...j] 的最长公共子序列的长度。

我们想求的最终答案就是`dp[text1.length() - 1][text2.length() - 1]`

**状态转移方程**：

- 如果 text1[i] != text2[j]，`dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])`
- 如果 text1[i] == text2[j]，`dp[i][j] = dp[i-1][j-1] + 1`

<img src="https://gitee.com/veal98/images/raw/master/img/20201008114921.png" style="zoom:67%;" />

顺序遍历即可。

按照我们这样的定义，其实各位写下代码后就会发现问题：

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        // dp[i][j] 表示序列 text1[0...i] 和 text2[0...j] 的最长公共子序列的长度
        int[][] dp = new int[text1.length()][text2.length()];

        // base case
        ......

        // 状态转移方程
        for (int i = 0; i < text1.length(); i ++) {
            for (int j = 0; j < text2.length(); j ++) {
                if (text1.charAt(i) == text2.charAt(j)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[text1.length() - 1][text2.length() - 1];
    }
}
```

没错，当 i = 0 或者 j = 0 的时候循环就会发生越界，因此我们需要做出特殊判断，其实也就是 base case，不过这种情况的 base case  不是很好写，我们需要计算出 `dp[0][j]` 以及 `dp[i][0]`。

拿 `dp[0][j]` 举例，只要 text2[0...j] 中有一个字符和 text1[0] 相等，则 `dp[0][j]` 就等于 1，显然这样的代码写起来复杂度比较高。

<br>

因此，我们考虑修改辅助数组的定义为这样：`dp[i][j]` 表示序列 text1[0...i-1] 和 text2[0...j-1] 的最长公共子序列的长度。这里的  i 、j 就表示第 i、第 j 个元素，而之前的定义中 i、j 表示下标为 i、j 的元素。

这样，我们想求的最终答案就是 `dp[text1.length()][text2.length()]`

那状态转移方程就是这样的：

- 如果 text1[`i-1`] != text2[`j-1`]，`dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])`
- 如果 text1[`i-1`] == text2[`j-1`]，`dp[i][j] = dp[i-1][j-1] + 1`

base case：

`dp[0][j] = 0, dp[i][0] = 0`，就是说如果有一个字符串为空，那么这两个字符串一定是不存在公共子序列的。

当然了，这样的 base case 也是可以不明确写出来的。

具体代码如下：

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        // dp[i][j] 表示序列 text1[0...i-1] 和 text2[0...j-1] 的最长公共子序列的长度
        int[][] dp = new int[text1.length() + 1][text2.length() + 1];

        // base case
        // for (int j = 0; j <= text2.length(); j ++) {
        //    dp[0][j] = 0;
        // }
        // for (int i = 0; i <= text1.length(); i ++) {
        //     dp[i][0] = 0;
        // }

        // 状态转移方程
        for (int i = 1; i <= text1.length(); i ++) {
            for (int j = 1; j <= text2.length(); j ++) {
                if (text1.charAt(i-1) == text2.charAt(j-1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[text1.length()][text2.length()];
    }
}
```

<br>

OK，至此我们求出了最长公共子序列的长度，那各位再来考虑一个问题，**如何求出具体的最长公共子序列呢？**（牛客网需要求的就是这个问题）

其实很简单，和 LIS 差不多，我们反着推一遍就行了。

dp 矩阵中最右下角的值 `dp[text1.length()][text2.length()]` 值代表 text1整体和 text2 整体的最长公共子序列的长度。从矩阵的右下角开始，有三种移动方式：向上、向左、向左上。用一个变量 res 来表示最长公共子序列。

1）如果 `dp[i][j]` 比 `dp[i-1][j]` 和 `dp[i][j-1]` 都要大，这说明之前在计算 `dp[i][j]` 的时候，没有走到代码中的那个 else 判断，也就是是选择了决策 `dp[i-1][j-1]+1`，即 text1.charAt(i-1) == text2.charAt(j-1)，显然，这个字符一定属于最长公共子序列，把这个字符放进结果 res 中，然后向左上方（也就是 `dp[i-1][j-1]` 的位置）移动。 

2）如果 `dp[i][j]` 等于 `dp[i-1][j]`，说明之前在计算 `dp[i][j]` 的时候，走到了代码中的那个 else 判断，因此向上方（也就是 `dp[i-1][j]` 的位置）移动即可。

同样的，如果 `dp[i][j]` 等于 `dp[i][j-1]`，向左方（也就是 `dp[i][j-1]` 的位置）移动。

这样，整体的 AC 代码如下：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String text1 = sc.nextLine();
        String text2 = sc.nextLine();

        int[][] dp = getDP(text1, text2);
        String res = generateLCS(text1, text2, dp);
        if (res.equals("")) {
            System.out.println(-1);
        }
        else {
            System.out.println(res);
        }
    }

    // 根据 dp 数组生成最长公共子序列
    private static String generateLCS(String text1, String text2, int[][] dp) {
        if (text1 == null || text2 == null || text1.equals("") || text2.equals("")) {
            return "";
        }

        char[] res = new char[dp[text1.length()][text2.length()]]; // 存储最长公共子序列

        int i = text1.length();
        int j = text2.length();
        int index = res.length - 1;
        while (index >= 0) {
            if (i > 0 && dp[i][j] == dp[i-1][j]) {
                i --;
            }
            else if (j > 0 && dp[i][j] == dp[i][j-1]) {
                j --;
            }
            else { // i > 0 && j > 0 && dp[i][j] == dp[i-1][j-1] + 1
                res[index--] = text1.charAt(i-1);
                i --;
                j --;
            }
        }

        return String.valueOf(res);
    }
    
     private static int[][] getDP(String text1, String text2) {
        // dp[i][j] 表示序列 text1[0...i-1] 和 text2[0...j-1] 的最长公共子序列的长度
        int[][] dp = new int[text1.length() + 1][text2.length() + 1];

        // 状态转移方程
        for (int i = 1; i <= text1.length(); i ++) {
            for (int j = 1; j <= text2.length(); j ++) {
                if (text1.charAt(i-1) == text2.charAt(j-1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp;
    }
}
```



#### LC516. 最长回文子序列 LPS

【题目链接】：

- [516 - 最长回文子序列 — Medium](计算机基础/算法/LeetCode/动态规划/516-最长回文子序列.md)

【题目描述】：

给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。

示例 1:

```
输入:

"bbbab"
输出:

4
一个可能的最长回文子序列为 "bbbb"。
```

示例 2:

```
输入:

"cbbd"
输出:

2
一个可能的最长回文子序列为 "bb"。
```

【解题思路】：

**辅助数组的定义**：`dp[i][j]` 表示 s[i...j] 的最长回文子序列的长度是 `dp[i][j]`

我们要求的就是 `dp[0][s.length() - 1]`

**状态转移方程**：

1）如果 `s[i] != s[j]`，则 `dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])`

如果 s[i] 和 s[j] 不相等， 说明他俩不可能同时出现在 `s[i : j]` 的最长回文序列中，那么将它们分别加入 `s[i+1 : j-1]` 中，看看哪个子串产生的回文子序列更长即可

<img src="https://gitee.com/veal98/images/raw/master/img/20201008150713.png" style="zoom:50%;" />

2）如果 `s[i] == s[j]`，则 `dp[i][j] = dp[i+1][j-1] + 2`

如果 s[i] 和 s[j] 相等， 那么 A = B + 2：

<img src="https://gitee.com/veal98/images/raw/master/img/20201008150659.png" style="zoom:50%;" />

注意这里的顺序，当然还有其他正确遍历的顺序，这里只列举其中之一：

![](https://gitee.com/veal98/images/raw/master/img/20210603214818.png)

**base case**：

每个单独的字符都是一个回文序列，即 `dp[i][i] = 1`

【具体代码】：

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        // dp[i][j] 表示 s[i...j] 的最长回文子序列的长度是 dp[i][j]
        int[][] dp = new int[s.length()][s.length()];

        // base case 
        for (int i = 0; i < s.length(); i ++) {
            dp[i][i] = 1;
        }

        // 状态转移方程
        for (int i = s.length() - 1; i >= 0; i --) {
            for (int j = i + 1; j <= s.length() - 1; j ++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                }
                else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[0][s.length() - 1];
    }
}
```

#### CD93/LC28. 数组中的最长连续子序列

【题目链接】：

- NowCoder：[CD93. 数组中的最长连续子序列](https://www.nowcoder.com/practice/c6b19ebae63143baa7fbb5b6d8dc24ec?tpId=101&&tqId=33161&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)
- LeetCode：[128. 最长连续序列 - Medium](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

【题目描述】：

给定**无序**数组 arr，返回其中最长的连续序列的长度(要求值连续，位置可以不连续,例如 3,4,5,6为连续的自然数）

输入描述：

输出两行，第一行包括一个整数 $n (1 \leq n \leq10^5)$ ,第 二行包含 n 个整数，分别代表 $arr[i] (1 \leq arr[i] \leq 10^8)$

输出描述：

输出一个整数，代表最长连续子序列的长度。

示例1

```
输入：
6
100 4 200 1 3 2

输出：
4
```

示例2

```
输入：
3
1 1 1

输出：
1
```

备注：

```
时间复杂度 O(nlog2n), 空间复杂度 O(n)。
```

【解题思路】：

> 经典的并查集问题，这里暂且就用哈希表 + 动态规划来解决

本题利用哈希表可以实现时间复杂度为O(N)、额外空间复杂度为O(N)的方法。具体过程如下：

![](https://gitee.com/veal98/images/raw/master/img/20210628221132.png)

【具体代码】：

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i ++) {
            arr[i] = sc.nextInt();
        }
        System.out.println(longestConsecutive(arr));
    } 
    
    private static int longestConsecutive(int[] arr) {
        if (arr == null || arr.length == 0) {
     	    return 0;              
        }
        
        // 最长连续子序列的长度
        int max = 1; 
        // key: 遍历过的某个数 value: 这个数所在的最长连续子序列的长度
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int i = 0; i < arr.length; i ++) {
            // 如果 arr[i] 之前出现过，直接遍历下一个数，只处理之前没出现过的 arr[i]
            if (!map.containsKey(arr[i])) {
                map.put(arr[i], 1);
                if (map.containsKey(arr[i] - 1)) {
                    // 将 arr[i]-1 所在的连续序列和 arr[i] 合并
                    max = Math.max(max, merge(map, arr[i] - 1, arr[i]));
                }
                if (map.containsKey(arr[i] + 1)) {
                    // 将 arr[i]+1 所在的连续序列和 arr[i] 合并
                    max = Math.max(max, merge(map, arr[i], arr[i] + 1));
                }
            }
        }
        
        return max;
    }
    
    // 合并 less 所在的序列和 more 所在的序列，返回合并后序列的长度
    private static int merge(HashMap<Integer, Integer> map, int less, int more) {
        // 找到元素 less 所在序列的最小元素的下标
        int left = less - map.get(less) + 1;      
        // 找到元素 more 所在序列的最大元素的下标
        int right = more + map.get(more) - 1;
        // 合并 less 所在的序列和 more 所在的序列
        int len = right - left + 1; 
        map.put(left, len);              
        map.put(right, len);
        // 返回合并后的序列长度
        return len;          
    }
}
```



### ② 子数组问题

#### CD33/LC718. 最长公共子串

> 注意这题和最长公共子序列问题的不同之处

【题目链接】：

- NowCoder：[CD33. 最长公共子串](https://www.nowcoder.com/practice/210741385d37490c97446aa50874e62d?tpId=101&&tqId=33101&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)
- LeetCode：[718. 最长重复子数组 — Medium](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

【题目描述】：

给定两个字符串 str1 和 str2, 输出两个字符串的最长公共子串，如果最长公共子串为空，输出 -1。

输入描述：

输入包括两行，第一行代表字符串 srr1，第二行代表字符串 str2。$\left( 1\leq length(str1),length(str2) \leq 5000 \right)$

输出描述：

输出包括一行，代表最长公共子串。

示例 1

```
输入：
1AB2345CD
12345EF

输出：
2345
```

备注：

```
时间复杂度O(n^{2})O(n2)，额外空间复杂度O(1)O(1)。（n可以为其中任意一个字符串长度）
```

【解题思路】：

**辅助数组的定义**：`dp[i][j]` 表示把 str1[i] 和 str2[j] 当作公共子串最后一个字符的情况下，公共子串最长能有多长。

- 若当前两个元素值相同，即 str1[i] == str2[j]，则说明当前元素可以构成公共子数组，所以还要加上它们的前一个元素构成的最长公共子数组的长度(在原来的基础上加 1)，此时状态转移方程：`dp[i][j] = dp[i - 1][j - 1] + 1`。
- 若当前两个元素值不同，即 A[i] != B[j]，则说明当前元素无法构成公共子数组(就是：当前元素不能成为公共子数组里的一员)。因为公共子数组必须是连续的，而此时的元素值不同，相当于直接断开了，此时状态转移方程：`dp[i][j] = 0`。

遍历一遍 dp 数组找到最大值即为最长公共子串的长度。

比如最大值是 `dp[3][4]==3`，说明最长公共子串的长度为 3。最长公共子串的最后一个字符是 str1[3]，当然也是 str2[4]，因为两个字符一样。那么最长公共子串为从 str1[3] 开始向左一共3字节的子串，即 str1[1..3]，当然也是 str2[2..4]。

base case ：

- 如果 `str1[0] = str2[j]`，则 `dp[0][j] = 1`
- 如果 `str2[0] = str1[i]`，则 `dp[i][0] = 1`，

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str1 = sc.nextLine();
        String str2 = sc.nextLine();

        int[][] dp = getDP(str1, str2);
        String res = generate(str1, str2, dp);
        if (res.equals("")) {
            System.out.println(-1);
        }
        else {
            System.out.println(res);
        }
    }

    private static int[][] getDP(String str1, String str2) {
        // dp[i][j] 表示把 str1[i] 和 str2[j] 当作公共子串最后一个字符的情况下，公共子串最长能有多长。
        int[][] dp = new int[str1.length()][str2.length()];

        // base case
        for (int j = 0; j < str2.length(); j ++) {
            if (str1.charAt(0) == str2.charAt(j)) {
                dp[0][j] = 1;
            }
        }
        for (int i = 0; i < str1.length(); i ++) {
            if (str2.charAt(0) == str1.charAt(i)) {
                dp[i][0] = 1;
            }
        }

        // 状态转移方程
        for (int i = 1; i < str1.length(); i ++) {
            for (int j = 1; j < str2.length(); j ++) {
                if (str1.charAt(i) == str2.charAt(j)) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                else {
                    dp[i][j] = 0;
                }
            }
        }

        return dp;
    }

    // 生成最长公共子串
    private static String generate(String str1, String str2, int[][] dp) {
        if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {
            return "";
        }

        // 遍历 dp 找到最大值
        int max = 0;
        int end = 0; // 最长公共子串在 str1 中的终止下标
        for (int i = 0;  i < dp.length; i ++) {
            for (int j = 0; j < dp[0].length; j ++) {
                if (max < dp[i][j]) {
                    max = dp[i][j];
                    end = i;
                }
            }
        }

        // 左闭右开
        return str1.substring(end - max + 1, end + 1);
    }
}
```

#### CD42. 子数组异或和为 0 的最多划分

【题目链接】：

- NowCoder：[CD42. 子数组异或和为 0 的最多划分](https://www.nowcoder.com/practice/77e9828bbe3c4d4a9e0d49cc7537bb6d?tpId=101&&tqId=33110&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)

【题目描述】：

给定一个整型数组 arr，其中可能有正有负有零。你可以随意把整个数组切成若干个不相容的子数组，求异或和为 0 的子数组最多可能有多少个？整数异或和定义：把数组中所有的数异或起来得到的值。

输入描述：

输出包括两行，第一行一个整数，代表数组长度 n (1≤*n*≤106)。第二行有 n 个整数，代表数组 $arr\left(-1e9 \leq arr_i \leq 1e9 \right)$。

输出描述：

输出一个整数，表示数组切割最多的子数组的个数。

示例 1：

输入：

```
10
3 2 1 9 0 7 0 2 1 3
```

输出：

```
4
```

说明：

```
最优划分：{3,2,1},{9},{0},{7},{0},{2,1,3} 其中{3,2,1},{0},{0},{2,1,3}的异或和为0
```

备注：

```
时间复杂度O(n)，空间复杂度O(n)
```

【解题思路】：

首先需要理解 “异或和” 的意思，比如说求 1、2、3 异或和，首先需要把十进制数转换成 2 进制，然后计算 0001 异或 0010 异或 0011 的值。

**辅助数组的定义**：`dp[i]` 的含义是如果在arr[0..i]上做分割，异或和为0的子数组最多能有多少个。

我们要求的就是 `dp[n-1]`

**状态转移方程**：

我们假设arr[0～i]上存在最优分割。显而易见的是，**分割出来的最后一个子数组一定包含arr[i]**，那么这个最优分割的最后一个子数组只可能有如下两种情况。

1）最优分割的最后一个子数组，异或和不等于 0。

那么很显然， `dp[i]` 的值等于 `dp[i-1]`。

2）最优分割的最后一个子数组，异或和等于 0。

假设 `arr[k..i]` 就是最优分割的最后一个子数组，并且异或和等于 0，那么 `dp[i]` 的值等于 `dp[k-1]+1`。那么如何求出 k 这个位置，就变成了唯一需要关心的问题。

<img src="https://gitee.com/veal98/images/raw/master/img/20210608230813.png" style="zoom: 50%;" />

<img src="https://gitee.com/veal98/images/raw/master/img/20210608230830.png" style="zoom:50%;" />

上图的例子可以看下图帮助理解：

![](https://gitee.com/veal98/images/raw/master/img/20210608232608.png)

**base case**：

如果 `arr[0] = 0`，则 `dp[0] = 1`，或者 `dp[0] = 0`。

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 数组的长度
        int[] arr = new int[n];
        for (int i = 0; i < n; i ++) {
            arr[i] = sc.nextInt();
        }

        System.out.println(mostEOR(arr));
    }

    private static int mostEOR(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }

        // 定义一个 map, key:某一个异或和 value:这个异或和上次出现的位置
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, -1);
        map.put(arr[0], 0);

        // dp[i] 的含义是如果在 arr[0..i]上做分割，异或和为 0 的子数组最多能有多少个。
        int[] dp = new int[arr.length];

        // base case
        dp[0] = (arr[0] == 0) ? 1 : 0;

        // 状态转移方程
        int eor = 0; // 异或和
        for (int i = 1; i < arr.length; i ++) {
            // 求异或和
            eor ^= arr[i];
            if (map.containsKey(eor)) {
                int preEorIndex = map.get(eor);
                dp[i] = (preEorIndex == -1) ? 1 : dp[preEorIndex] + 1;
                map.put(eor, map.get(eor));
            }
            dp[i] = Math.max(dp[i-1], dp[i]);
            map.put(eor, i);
        }

        return dp[arr.length - 1];
    }

}
```

## 跑图问题

### CD17. 机器人达到指定位置方法数

【题目链接】：

- NowCoder：[CD17. 机器人达到指定位置方法数](https://www.nowcoder.com/practice/54679e44604f44d48d1bcadb1fe6eb61?tpId=101&&tqId=33085&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)

【题目描述】：

假设有排成一行的 N 个位置，记为 1~N，开始时机器人在 M 位置，机器人可以往左或者往右走，如果机器人在 1 位置，那么下一步机器人只能走到 2 位置，<u>如果机器人在 N 位置，那么下一步机器人只能走到 N-1 位置</u>。**规定机器人只能走 k 步，最终能来到 P 位置的方法有多少种**。由于方案数可能比较大，所以答案需要对 1e9+7 取模。

输入描述：

输出包括一行四个正整数 N（2<=N<=5000）、M (1<=M<=N)、K (1<=K<=5000)、P (1<=P<=N)。

输出描述：

输出一个整数，代表最终走到 P 的方法数对 10^9+7 取模后的值。

示例 1

```
输入：
5 2 3 3

输出：
3

说明：
1).2->1,1->2,2->3

2).2->3,3->2,2->3

3).2->3,3->4,4->3
```

示例 2：

```
输入：
1000 1 1000 1

输出：
591137401

说明：
注意答案要取模
```

【解题思路】：

由于题目给的排成一行的 N 个位置，所以只需要用一维就能表示一个位置。

**辅助数组的定义**：`dp[i][j]` 表示当前的的位置是 i（下标是 i - 1），还能够走 j 步（一共可以走 k 步），最终能来到 P 位置的方法有 `dp[i][j]` 种

开始时机器人在 M 位置，所以我们最终要求的就是 `dp[M][K]`

**状态转移方程**：

- 如果当前位置是 1，则只能向右走到 2 的位置，`dp[i][j] = dp[i+1][j-1]`
- 如果当前位置是 N，则只能向左走到 N-1 的位置，`dp[i][j] = dp[i-1][j-1]`
- 如果当前位置不是 1 也不是 N，则可以向右走也可以向左走，`dp[i][j] = dp[i+1][j-1] + dp[i-1][j-1]`

这里尤其需要注意的是！！！循环的顺序！！！

按照状态转移方程，在计算 `dp[i][j]` 之前，我们需要先计算 `dp[i+1][j-1] 和 dp[i-1][j-1]`

<img src="https://gitee.com/veal98/images/raw/master/img/20210529222145.png" style="zoom:67%;" />

如果我们按照

```java
for (int i = 1; i <= N; i ++) {
	for (int j = 1; j <= K; j ++) {
```

是无法得出正确答案的。

![](https://gitee.com/veal98/images/raw/master/img/20210529222446.png)

**base case**：

如果当前位置就在 P，并且只能走 0 步也就是不能再走了，这种情况下，来到 P 位置的方法 `dp[P][0] = 1`;

【具体代码】

题目说了，由于方案数可能比较大，所以答案需要对 1e9+7 取模。

```java
public class Main {

    private static final int mod = 1000000000 + 7;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt(); // 有排成一行的 N 个位置，记为 1~N
        int M = sc.nextInt(); // 开始时机器人在 M 位置
        int K = sc.nextInt(); // 机器人只能走 k 步
        int P = sc.nextInt(); // 问最终能来到 P 位置的方法有多少种

        System.out.println(getWays(N, M, K, P));
    }

    private static int getWays(int N, int M, int K, int P) {
        // dp[i][j] 表示当前的的位置是 i（下标是 i - 1），还能够走 j 步（一共可以走 k 步）
        // 最终能来到 P 位置的方法有 dp[i][j] 种
        int[][] dp = new int[N + 1][K + 1];

        // base case
        dp[P][0] = 1;

        // 状态转移方程
        for (int j = 1; j <= K; j ++) {
            for (int i = 1; i <= N; i ++) {
                // 如果当前位置是 1，则只能向右走到 2 的位置
                if (i == 1) {
                    dp[i][j] = dp[i + 1][j - 1];
                }
                // 如果当前位置是 N，则只能向左走到 N-1 的位置
                else if (i == N) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                // 如果当前位置不是 1 也不是 N，则可以向右走也可以向左走
                else {
                    dp[i][j] = (dp[i + 1][j - 1] + dp[i - 1][j - 1]) % mod;
                }
            }
        }

        return (dp[M][K]) % mod;
    }
}
```

### CD45. 龙与地下城游戏问题

【题目链接】：

- NowCoder：[CD45. 龙与地下城游戏问题](https://www.nowcoder.com/practice/c0ca4c9e65144af69ada03febaa0e33a?tpId=101&&tqId=33113&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)

【题目描述】：

给定一个二维数组 map，含义是一张地图，例如，如下矩阵

$\begin{Bmatrix} -2&-3&3 \\ -5&-10&1\\ 0&30&-5 \end{Bmatrix}$

游戏的规则如下：

1）骑士从左上角出发，每次只能向右或向下走，最后到达右下角见到公主。

2）地图中每个位置的值代表骑士要遭遇的事情。如果是负数，说明此处有怪兽，要让骑士损失血量。如果是非负数，代表此处有血瓶，能让骑士回血。

3）骑士从左上角到右下角的过程中，走到任何一个位置时，血量都不能少于 1。为了保证骑土能见到公主，初始血量至少是多少?

根据 map, 输出初始血量

输入描述：

第一行两个正整数 n，$m \left ( 1\leq n,m\leq 10^{3} \right )$，接下来 n 行，每行 m 个整数，代表 $map_{ij} \left( -10^3 \leq map_{ij} \leq 10^{3}\right )$

输出描述：

输出一个整数，表示答案。

示例 1

```
输入：
3 3
-2 -3 3
-5 -10 1
0 30 -5

输出：
7
```

示例 2

```
输入：
2 2
1 1
1 1

输出：
1
```

备注：

```
时间复杂度O(n*m)O(n∗m),额外空间复杂度O(min(n,m))O(min(n,m))
```

【解题思路】：

**辅助数组的定义：**`dp[i][j]` 表示如果骑士到达位置（i, j）时最少应该具备的血量

则我们最终需要求的就是 `dp[0][0]`

举个例子：

<img src="https://gitee.com/veal98/images/raw/master/img/20210615230521.png" style="zoom:50%;" />



`map[2][2]` 的值为 -5，所以骑士若要走上这个位置，需要 6 点血才能让自己不死。同时位置（2,2）已经是最右下角的位置，即没有后续的路径，所以 `dp[2][2]==6`。

**状态转移方程：**

- 如果骑士决定向右走，那么骑士在当前位置（i, j）加完血或者扣完血之后的血量只要等于 `dp[i][j+1]` （到达 （i，j+1）位置时最少应该具备的血量）即可。也就是说，骑士在加血或扣血之前的血量要求（也就是在没有踏上（i, j）位置之前的血量要求），就是 `dp[i][j] = dp[i][j+1] - map[i][j]`。同时，骑士血量要随时不少于 1，所以向右的要求为 `max{dp[i][j+1] - map[i][j], 1}`。
- 如果骑士决定向下走，分析方式相同，向下的要求为 `max{dp[i+1][j] - map[i][j],1}`

骑士可以有两种选择，当然要选最优的一条，所以 `dp[i][j] = min{向右的要求，向下的要求}`。

注意这里的顺序问题，计算 dp 矩阵时从右下角开始计算，选择依次从右至左，再从下到上的计算方式即可

**base case：**

1）最后一格（这个在上面的例子中已经说的很明白了）：`dp[n-1][m-1] = map[n-1][m-1] > 0 ? 1 : -map[n-1][m-1] + 1;`

2）我们可以根据最后一格求出最后一行和最后一列的所有格子：

```java
// 最后一行
for (int j = col - 1; j >= 0; j --) {
    dp[row][j] = Math.max(dp[row][j + 1] - map[row][j], 1);
}
// 最后一列
for (int i = row - 1; i >= 0; i --) {
    dp[i][col] = Math.max(dp[i + 1][col] - map[i][col], 1);
}
```

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[][] map = new int[n][m];
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < m; j ++) {
                map[i][j] = sc.nextInt();
            }
        }

        System.out.println(minHP(map));
    }

    private static int minHP(int[][] map) {
        if (map == null || map.length == 0 || map[0].length == 0) {
            return 1;
        }

        int row = map.length;
        int col = map[0].length;

        // dp[i][j] 表示如果骑士到达位置（i, j）时最少应该具备的血量
        int[][] dp = new int[row][col];

        // base case
        row --;
        col --;
        // 最后一格
        dp[row][col] = map[row][col] > 0 ? 1 : 1 - map[row][col];
        // 最后一行
        for (int j = col - 1; j >= 0; j --) {
            dp[row][j] = Math.max(dp[row][j + 1] - map[row][j], 1);
        }
        // 最后一列
        for (int i = row - 1; i >= 0; i --) {
            dp[i][col] = Math.max(dp[i + 1][col] - map[i][col], 1);
        }

        // 状态转移方程
        for (int i = row - 1; i >= 0; i --) {
            for (int j = col - 1; j >= 0; j --) {
                // 向右
                int right = Math.max(dp[i][j + 1] - map[i][j], 1);
                // 向下
                int down = Math.max(dp[i + 1][j] - map[i][j], 1);

                dp[i][j] = Math.min(right, down);
            }
        }

        return dp[0][0];
    }

}
```



## CD20. 打气球的最大分数

【题目链接】：

- NowCoder：[CD20. 打气球的最大分数](https://www.nowcoder.com/practice/35119064d0224c35ab1ab612bffee8df?tpId=101&&tqId=33088&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)

【题目描述】：

给定一个数组 arr,长度为 n。代表排有分数的气球。 每打爆一个气球都能获得分数，假设打爆气球的分数为X，获得分数的规则如下 :

1) 如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L : 如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R. 获得分数为 `L * X * R`

2) 如果被打爆的气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L : 如果被打爆气球的右边所有气球都已经被打爆，获得分数为 L * X。

3) 如果被打爆气球的左边所有的气球都已经被打爆:如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球。获得分数为 X * R.

4) 如果被打爆气球的左边和右边所有的气球都已经被打爆。获得分数为 X。

目标是打爆所有气球，获得每次打爆的分数。通过选择打爆气球的顺序，可以得到不同的总分，请返回能获得的最大分数。

输入描述：

输出包括两行，第一行包括一个整数 n（0<=n<=500），第二行包括 n 个整数，代表数组 arr （1<=arr[i]<=100）。

输出描述：

输出包括一个整数，代表可能获得的最大分数。

示例 1

```
输入：
3
3 2 5

输出：
50

说明：
2->1->3  3*2*5+3*5+5=50 
```

示例 2

```
输入：
8
23 4 45 65 23 43 54 56

输出：
639019
```

【解题思路】：

**辅助表的定义**：`dp[i][j]` 表示打爆第 i 个气球到第 j 个气球可能获得的最大得分

则我们要求的就是 `dp[1][n]`

**状态转移方程**：

1）最后打爆第 i 个气球（arr[i]）的最大分数：`int finalL = arr[i - 2] * arr[i - 1] * arr[j] + dp[i + 1][j]`

2）最后打爆第 j 个气球（arr[j]）的最大分数：`int finalR = arr[i - 2] * arr[j-1] * arr[j] + dp[i][j - 1]`

3）最后打爆 `[i, j]` 中间第 k 个气球（arr[k]）的最大分数：`int finalLR = dp[i][k - 1] + dp[k + 1][j] + arr[i - 2] * arr[k - 1] * arr[j]`

**base case**：

`dp[i][i] = arr[i-2] * arr[i-1] * arr[i]` ，最开始的时候，打爆某个气球获得的分数就是这个气球的分数乘以其左右两边气球的分数。

不过，从上面的状态转移方程我们能看出一个问题，那就是 i - 2 可能会超出下标界限，因此，需要对其进行判断。那为了减少点麻烦，这里我就直接开辟了一个新数组 help，help[0] = 1, help[n + 1] = 1。这样，就不需要特别的进行判断了，不过这样的话，第 i 个气球对于的新数组 help 的下标就是 i 而不是 i - 1 了。

另外，对于本题的循环顺序也需要注意，大致如下：

![](https://gitee.com/veal98/images/raw/master/img/20210531214530.png)

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i ++) {
            arr[i] = sc.nextInt();
        }

        System.out.println(maxScores(arr));
    }

    private static int maxScores(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        if (arr.length == 1) {
            return arr[0];
        }

        int n = arr.length;

        int[] help = new int[n + 2];
        help[0] = 1;
        help[n + 1] = 1;
        for (int i = 1; i <= n; i ++) {
            help[i] = arr[i - 1];
        }

        // dp[i][j] 表示打爆第 i 个气球到第 j 个气球可能获得的最大得分
        int[][] dp = new int[n + 2][n + 2];

        // base case
        for (int i = 1; i < n; i ++) {
            dp[i][i] = help[i - 1] * help[i] * help[i + 1];
        }

        // 状态转移方程
        for (int i = n; i >= 1; i --) {
            for (int j = i + 1; j <= n; j ++) {
                // 最后打爆第 i 个气球 (arr[i]) 的最大分数
                int finalL = help[i - 1] * help[i] * help[j + 1] + dp[i + 1][j];
                // 最后打爆第 j 个气球 (arr[j]) 的最大分数
                int finalR = help[i - 1] * help[j] * help[j + 1] + dp[i][j - 1];
                // 最后打爆 [i, j] 中间第 k 个气球 (arr[k]) 的最大分数
                int finalLR = 0;
                for (int k = i + 1; k < j; k ++) {
                    int temp = dp[i][k - 1] + dp[k + 1][j] + help[i - 1] * help[k] * help[j + 1];
                    finalLR = Math.max(finalLR, temp);
                }

                dp[i][j] = Math.max(Math.max(finalL, finalR), finalLR);
            }
        }

        return dp[1][n];
    }
}
```

## CD43. 最小编辑代价

【题目链接】：

- NowCoder：[CD43. 最小编辑代价](https://www.nowcoder.com/practice/dfa502cf6a914fb5b98c59c56619e96c?tpId=101&&tqId=33111&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)

【题目描述】：

给定两个字符串 str1 和 str2，再给定三个整数 ic，dc 和 rc，分别代表插入、删除和替换一个字符的代价，请输出将str1编辑成str2的最小代价。

输入描述：

输出三行，第一行和第二行均为一行字符串，分别表示两个字符串 str1，str2。$\left( 1\leq length(str1),length(str2) \leq 5000 \right)$，第三行为三个正整数，代表 ic，dc 和 rc。（1<=ic<=10000、1<=dc<=10000、1<=rc<=10000）

输出描述：

输出一个整数，表示编辑的最小代价。

示例 1

```
输入：
abc
adc
5 3 2

输出：
2
```

示例 2

```
输入：
abc
adc
5 3 100

输出：
8
```

示例3

```
输入：
abc
abc
5 3 2

输出：
0
```

备注：

```
时间复杂度O(n*m)，空间复杂度O(n)。(n,m代表两个字符串长度)
```

【解题思路】：

**辅助数组定义**：`dp[i][j]` 表示将字符串 `str1[0..i-1]` 编辑成 `str2[0...j-1]` 需要的最少代价

则最终需要我们求的就是：`dp[str1.length][str2.length]`

**状态转移方程**：

`dp[i][j]` 的值只可能有以下四种情况：

- str1[0..i-1] 可以先编辑成 str1[0..i-2]，也就是先删除字符 str1[i-1]，然后由 str1[0..i-2] 编辑成 str2[0..j-1], `dp[i-1][j]` 表示 str1[0..i-2] 编辑成 str2[0..j-1] 的最小代价，那么 `dp[i][j]` 可能等于 `dc + dp[i-1][j]`。

-  str1[0..i-1] 可以先编辑成 str2[0..j-2]，然后将 str2[0..j-2]插入字符 str2[j-1]，编辑成 str2[0..j-1], `dp[i][j-1]` 表示 str1[0..i-1] 编辑成 str2[0..j-2]的最小代价，那么 `dp[i][j]` 可能等于 `dp[i][j-1]+ic`。

- 如果 **str1[i-1] ! = str2[j-1]**。先把 str1[0..i-1] 中 str1[0..i-2] 的部分变成 str2[0..j-2]，然后把字符 str1[i-1]替换成 str2[j-1]，这样 str1[0..i-1]就编辑成str2[0..j-1]了。`dp[i-1][j-1]` 表示str1[0..i-2]编辑成str2[0..i-2]的最小代价，那么`dp[i][j]` 可能等于 `dp[i-1][j-1]+rc`。

  <img src="https://gitee.com/veal98/images/raw/master/img/20210610211345.png" style="zoom:50%;" />

- 如果 **str1[i-1] == str2[j-1]**。先把str1[0..i-1]中str1[0..i-2]的部分变成str2[0..j-2]，因为此时字符 str1[i-1]等于 str2[j-1]，所以 str1[0..i-1]已经编辑成str2[0..j-1]了。`dp[i-1][j-1]` 表示str1[0..i-2]编辑成str2[0..i-2]的最小代价，那么 `dp[i][j]` 可能等于 `dp[i-1][j-1]`。

**base case**：

- `dp[i][0] = dc * i`，`dp[i][0]` 的意思就是将 字符串 str1 转换成空串，那显然就是删除 str1 中的所有字符就行了
- `dp[0][j] = ic * j`，`dp[0][j]` 的意思就是将 空串 str1 转换成字符串 str2，那显然需要不断地往 str1 中添加新字符

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str1 = sc.nextLine();
        String str2 = sc.nextLine();
        int ic = sc.nextInt(); // 插入的代价
        int dc = sc.nextInt(); // 删除的代价
        int rc = sc.nextInt(); // 替换的代价

        System.out.println(minCost(str1, str2, ic, dc, rc));
    }

    private static int minCost(String str1, String str2, int ic, int dc, int rc) {
        // dp[i][j] 表示将字符串 `str1[0..i-1]` 编辑成 `str2[0...j-1]` 需要的最少代价
        int[][] dp = new int[str1.length() + 1][str2.length() + 1];

        // base case
        for (int i = 1; i <= str1.length(); i ++) {
            dp[i][0] = dc * i;
        }
        for (int j = 1; j <= str2.length(); j ++) {
            dp[0][j] = ic * j;
        }

        // 状态转移方程
        for (int i = 1; i <= str1.length(); i ++) {
            for (int j = 1; j <= str2.length(); j ++) {
                if (str1.charAt(i-1) == str2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];
                }
                else {
                    dp[i][j] = dp[i-1][j-1] + rc;
                }
                dp[i][j] = Math.min(dp[i][j], dp[i][j-1] + ic);
                dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + dc);
            }
        }

        return dp[str1.length()][str2.length()];
    }
}
```

## CD44. 字符串的交错组成

【题目链接】：

- NowCoder：[CD44. 字符串的交错组成](https://www.nowcoder.com/practice/1fdefa4178f7460d93738b28441e1277?tpId=101&&tqId=33112&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)

【题目描述】：

给定三个字符串str1、str2 和aim,如果aim包含且仅包含来自str1和str2的所有字符，而且在aim中属于str1的字符之间保持原来在str1中的顺序属于str2的字符之间保持原来在str2中的顺序，那么称aim是str1和str2的交错组成。实现一个函数，判断aim是否是str1和str2交错组成，如果是请输出“YES”，否则输出“NO”。

输入描述：

输出三行，分别表示三个字符串 str1，str2 和 aim。

$1 \leq length\left ( str1 \right ),length\left ( str2 \right ) \leq 5000 ,1 \leq length\left(aim \right) \leq10000$ 表示字符串长度。

输出描述：

输出“YES”或者“NO”。（不包含引号）

示例 1

```
输入：
AB
12
1AB2

输出：
YES
```

示例2

```
输入：
2019
9102
22001199

输出：
NO
```

备注：

```
时间复杂度 O(n∗m),空间复杂度 O(min(n,m))。（n表示字符串str1长度，m表示s字符串str2长度）
```

【解题思路】：

**辅助数组的定义**：`dp[i][j]` 表示 aim[0..i+j-1] 能否被 str1[0..i-1] 和 str2[0..j-1] 交错组成。

则我们最终要求的就是 `dp[str1.length()][str2.length()]`

**状态转移方程**：

- `dp[i-1][j]` 代表 aim[0..i+j-2] 能否被 str1[0..i-2]和 str2[0..j-1] 交错组成，<u>如果可以，那么如果再有 str1[i-1] 等于 aim[i+j-1]</u>，说明 str1[i-1] 又可以作为交错组成 aim[0..i+j-1] 的最后一个字符。令 `dp[i][j]=true`。
- `dp[i][j-1]` 代表 aim[0..i+j-2]能否被 str1[0..i-1]和 str2[0..j-2]交错组成，<u>如果可以，那么如果再有str2[j-1]等于aim[i+j-1]</u>，说明str1[j-1]又可以作为交错组成aim[0..i+j-1]的最后一个字符。令 `dp[i][j]=true`。
- 如果第 1 种情况和第 2 种情况都不满足，令 `dp[i][j]=false`。

**base case**：

- `dp[0][0]=true`。aim 为空串时，当然可以被 str1 为空串和 str2 为空串交错组成。
- `dp[i][0]` 表示 aim[0..i-1] 能否只被 str1[0..i-1]交错组成。如果 aim[0..i-1] 等于 str1[0..i-1]，则令 `dp[i][0]=true`，否则令 `dp[i][0]=false`。
- `dp[0][j]` 表示 aim[0..j-1] 能否只被 str2[0..j-1] 交错组成。如果 aim[0..j-1]等于str1[0..j-1]，则令 `dp[i][0]=true`，否则令 `dp[i][0]=false`。

【具体代码】：

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str1 = sc.nextLine();
        String str2 = sc.nextLine();
        String aim = sc.nextLine();

        boolean res = isCross(str1, str2, aim);
        if (res) {
            System.out.println("YES");
        }
        else {
            System.out.println("NO");
        }
    }

    private static boolean isCross(String str1, String str2, String aim) {
        if (str1 == null || str2 == null || aim == null) {
            return false;
        }
        if (aim.length() != str1.length() + str2.length()) {
            return false;
        }

        // dp[i][j] 表示 aim[0..i+j-1] 能否被 str1[0..i-1] 和 str2[0..j-1] 交错组成。
        boolean[][] dp = new boolean[str1.length() + 1][str2.length() + 1];

        // base case
        dp[0][0] = true;
        for (int i = 1; i <= str1.length(); i ++) {
            if (str1.charAt(i-1) != aim.charAt(i-1)) {
                break;
            }
            dp[i][0] = true;
        }
        for (int j = 1; j <= str2.length(); j ++) {
            if (str2.charAt(j-1) != aim.charAt(j-1)) {
                break;
            }
            dp[0][j] = true;
        }

        // 状态转移方程
        for (int i = 1; i <= str1.length(); i ++) {
            for (int j = 1; j <= str2.length(); j ++) {
                if (dp[i-1][j] && str1.charAt(i-1) == aim.charAt(i+j-1) ||
                    dp[i][j-1] && str2.charAt(j-1) == aim.charAt(i+j-1)) {
                    dp[i][j] = true;
                }
            }
        }

        return dp[str1.length()][str2.length()];
    }
}
```

## CD91. 排成一条线的纸牌博弈问题

【题目链接】：

- NowCoder：[排成一条线的纸牌博弈问题](https://www.nowcoder.com/practice/19c98d950b3347d19f991d10bde12288?tpId=101&&tqId=33159&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)

【题目描述】：

给定一个整型数组arr，代表数值不同的纸牌排成一条线，玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左和最右的纸牌，玩家 A 和玩家 B 绝顶聪明。请返回最后的获胜者的分数。

输入描述：

输出包括两行，第一行一个整数 n $(1 \leq n \leq 5000 )$，代表数组 arr 长度，第二行包含 n 个整数，第i个代表 $arr[i]( 1 \leq arr[i] \leq 10^5 )$。

输出描述：

输出一个整数，代表最后获胜者的分数。

示例1

```
输入：
4
1 2 100 4

输出：
101
```

备注：

```
时间复杂读O(n^2),空间复杂度O(n^2)
```

【解题思路】：

这个题目和我们平常所做的动态规划问题有一些不一样的地方就在于，这里存在一个先后问题，所以我们需要两个数组，一个用来统计先拿纸牌的玩家能够获得的最大分数，另一个用来统计后拿纸牌的玩家能够获得的最大分数。

**辅助数组的定义**：

`dp1[i][j]` 表示先拿纸牌的玩家从 `arr[i...j]` 这个排列上能够取得的最高分数

`dp2[i][j]` 表示后拿纸牌的玩家从 `arr[i...j]` 这个排列上能够取得的最高分数

**状态转移方程**：

1）对于先拿纸牌的玩家：

- 如果只剩一张牌（即 `i == j`），当然会被先拿纸牌的玩家拿走，所以 `dp1[i][i] == arr[i]`（**base case**）

- 如果 `i != j`，那么当前拿纸牌的玩家（假设是玩家 A）有两种选择，要么拿走最左边 arr[i]，要么拿走最右边 arr[j]：

  - 如果拿走 arr[i]，那么排列将剩下 `arr[i+1..j]`。面对剩下的 `arr[i+1..j]` 排列的纸牌，玩家 A 需要等玩家 B 拿完后他才能拿，所以实际上玩家 A 此时成了 `arr[i+1..j]` 排列中后拿的玩家，所以后续他能获得的分数为 `dp2[i+1][j]`。
  - 如果拿走 arr[j]，那么排列将剩下 `arr[i..j-1]`。同样的，面对剩下的 `arr[i..j-1]` 排列的纸牌，玩家 A 需要等玩家 B 拿完后他才能拿，所以实际上玩家 A 此时成了 `arr[i..j-1]` 排列中后拿的玩家，所以后续他能获得的分数为 `dp2[i][j-1]`。

  作为绝顶聪明的人，必然会在两种决策中选最优的。所以 `dp1[i][j] = max{arr[i] + dp2[i+1][j] , arr[j] + dp2[i][j-1]}`。

2）对于后拿纸牌的玩家：（和上面的分析相反）

- 如果只剩一张牌（即 `i == j`），作为后拿纸牌的玩家必然什么也得不到，所以 `dp2[i][i] == 0`（**base case**）

- 如果 `i != j`。当前玩家是后拿纸牌的（假设是玩家 B），他的对手 A 会先拿纸牌，对手要么拿走 arr[i]，要么拿走 arr[j]：

  - 如果对手拿走 arr[i]，那么排列将剩下 `arr[i+1..j]`，所以实际上玩家 B 此时成了 `arr[i+1..j]` 排列中先拿的玩家，所以后续他能获得的分数为 `dp1[i+1][j]`。
  - 如果对手拿走arr[j]，那么排列将剩下 `arr[i..j-1]`，所以实际上玩家 B 此时成了 `arr[i..j-1]` 排列中先拿的玩家，所以后续他能获得的分数为 `dp1[i][j-1]`。

  由于先拿纸牌的玩家 A 也是绝顶聪明的人，必然会把最差的情况留给后拿纸牌的玩家 B。所以 `dp2[i][j] = min{dp1[i+1][j] , dp2[i][j-1]}`。

【具体代码】：

按照状态转移方程写就行了，注意这里的循环顺序问题。

```java
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i ++) {
            arr[i] = sc.nextInt();
        }
        System.out.println(win(arr));
    }

    private static int win(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }

        // dp1[i][j] 表示先拿纸牌的玩家从 arr[i...j] 这个排列上能够取得的最高分数
        int[][] dp1 = new int[arr.length][arr.length];
        // dp2[i][j] 表示后拿纸牌的玩家从 arr[i...j] 这个排列上能够取得的最高分数
        int[][] dp2 = new int[arr.length][arr.length];

        // base case
        for (int i = 0; i < arr.length; i ++) {
            dp1[i][i] = arr[i];
            // dp2[i][i] = 0;
        }

        // 状态转移方程
        for (int j = 0; j < arr.length; j ++) {
            for (int i = j - 1; i >= 0; i --) {
                dp1[i][j] = Math.max(arr[i] + dp2[i+1][j], arr[j] + dp2[i][j-1]);
                dp2[i][j] = Math.min(dp1[i+1][j], dp1[i][j-1]);
            }
        }

        return Math.max(dp1[0][arr.length-1], dp2[0][arr.length-1]);

    }
}
```

## CD92/LC55. 跳跃游戏

【题目链接】：

- NowCoder：[CD92. 跳跃游戏](https://www.nowcoder.com/practice/b7d9d79453bf43bf9594e91d24260605?tpId=101&&tqId=33160&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking)
- LeetCode：[55. 跳跃游戏 — Medium](https://leetcode-cn.com/problems/jump-game/)

【题目描述】：

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。比如 `nums[2] = 3` 表示：在下标 2 的位置上，你可以跳 1 步 或者 2 步 或者 3 步。

问：判断你是否能够到达最后一个下标。

示例 1：

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```


示例 2：

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

【解题思路】：

> 这个问题也可以用贪心来解决

**辅助数组的定义**：`dp[i]` 表示下标 i 是否可以到达

则我们最终要求的就是 `dp[n-1]`

**base case**：`dp[0] == ture`

**动态转移方程**：首先判断倒数第二个元素能否到达最后一个元素，如果可以，我们就不用再考虑最后一个元素了，因为根据刚才的分析如果可以到达倒数第二个，那么一定可以到达最后一个元素。

然后依次往前递推，如果都能跳到的话，我们最后应该分析的就是第一个元素能否跳到第二个元素上。

即如果下标 j 可以到达并且从 j 可以到达 i，那么下标 i 就是可以到达的：`dp[j] && nums[j] + j >= i`，则 `dp[i] == true`

【具体代码】：

```java
class Solution {
    public boolean canJump(int[] nums) {
        if (nums == null || nums.length == 0) {
            return false;
        }

        // dp[i] 表示下标 i 是否可以到达
        boolean[] dp = new boolean[nums.length];

        // base case
        dp[0] = true;

        // 状态转移方程
        for (int i = 1; i < nums.length; i ++) {
            for (int j = 0; j < i; j ++) {
                if (dp[j] && j + nums[j] >= i) {
                    dp[i] = true;
                    // 一旦知道 i 是可以到达的就不用再继续了，直接进入下一个位置的判断
                    break;
                }
            }
        }

        return dp[nums.length - 1];
    }
}
```

